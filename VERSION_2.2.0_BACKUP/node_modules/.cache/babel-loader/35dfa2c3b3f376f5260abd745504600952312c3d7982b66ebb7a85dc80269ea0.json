{"ast":null,"code":"import _objectSpread from\"/Users/nic/housing-deadlines-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\n * Recurring Task Generator\n * Automatically generates instances from recurring tasks\n */import{parse,isValid,addMonths,format}from'date-fns';import recurringInstanceService from'./recurringInstanceService';import{globalTaskStore}from'./globalTaskStore';class RecurringTaskGenerator{constructor(){this.maxYear=2050;}/**\n   * Parse deadline date string to Date object\n   */parseDeadlineDate(dateStr){if(!dateStr)return null;// Extract date components to avoid timezone issues\nlet year,month,day;// Try ISO format first (SharePoint format: 2024-10-09T00:00:00Z or 2024-10-09)\nif(typeof dateStr==='string'&&dateStr.includes('-')){const datePart=dateStr.split('T')[0];// Get just the date part\nconst parts=datePart.split('-');if(parts.length===3){year=parseInt(parts[0],10);month=parseInt(parts[1],10)-1;// JS months are 0-indexed\nday=parseInt(parts[2],10);if(!isNaN(year)&&!isNaN(month)&&!isNaN(day)){// Create date at noon local time to avoid timezone shifts\nreturn new Date(year,month,day,12,0,0);}}}// Try explicit formats with date-fns as fallback\nconst formats=['MM/dd/yyyy','M/d/yy','M/d/yyyy','MM/dd/yy'];for(const fmt of formats){const d=parse(dateStr,fmt,new Date());if(isValid(d)){// Set to noon to avoid timezone issues\nd.setHours(12,0,0,0);return d;}}return null;}/**\n   * Parse final date string to Date object\n   */parseFinalDate(dateStr){if(!dateStr)return null;return this.parseDeadlineDate(dateStr);}/**\n   * Generate instances for a single recurring task\n   */async generateInstancesForTask(task){console.log('RecurringTaskGenerator: Generating instances for task:',task.Task||task.id);console.log('RecurringTaskGenerator: Task Recurring field:',task.Recurring,typeof task.Recurring);// Check if task is recurring - handle various formats\nconst recurringValue=String(task.Recurring||'').trim();const isRecurring=recurringValue.toLowerCase()==='yes'||recurringValue.toLowerCase()==='true'||task.Recurring===true;console.log('RecurringTaskGenerator: Task Recurring field:',task.Recurring,typeof task.Recurring,'normalized:',recurringValue,'isRecurring:',isRecurring);if(!isRecurring){console.log('RecurringTaskGenerator: Task is not recurring (Recurring field is not \"Yes\" or \"True\"), skipping');return;}// Validate required fields\nif(!task.Interval||!task.Deadline){console.log('RecurringTaskGenerator: Missing required fields (Interval or Deadline)');return;}const interval=parseInt(task.Interval,10);if(isNaN(interval)||interval<1){console.log('RecurringTaskGenerator: Invalid interval:',task.Interval);return;}const startDate=this.parseDeadlineDate(task.Deadline);if(!startDate){console.log('RecurringTaskGenerator: Invalid start date:',task.Deadline);return;}console.log('RecurringTaskGenerator: Parsed deadline:',{raw:task.Deadline,parsed:startDate.toISOString(),localDate:startDate.toLocaleDateString(),year:startDate.getFullYear(),month:startDate.getMonth()+1,day:startDate.getDate()});// Determine end date\nlet endDate;if(task.FinalDate){endDate=this.parseFinalDate(task.FinalDate);if(!endDate){// If finalDate is invalid, use maxYear\nendDate=new Date(this.maxYear,11,31);}}else{// No finalDate specified, use maxYear\nendDate=new Date(this.maxYear,11,31);}// Ensure endDate doesn't exceed maxYear\nconst maxEndDate=new Date(this.maxYear,11,31);if(endDate>maxEndDate){endDate=maxEndDate;}console.log('RecurringTaskGenerator: Generating instances from',format(startDate,'yyyy-MM-dd'),'to',format(endDate,'yyyy-MM-dd'));// Get existing instances to preserve modifications\nconst existingInstances=await recurringInstanceService.getInstancesByParent(task.id);const existingInstancesMap=new Map(existingInstances.map(inst=>[inst.id,inst]));console.log('RecurringTaskGenerator: Found',existingInstances.length,'existing instances with modifications to preserve');// Generate instances starting from the FIRST occurrence (the parent's date)\n// This creates a \"current year clone\" in the sub-database so users can work with it\nconst instances=[];let currentDate=new Date(startDate);// Start from the parent's date, not the next recurrence\nlet instanceNumber=0;// Start from 0 so first instance is labeled correctly\nwhile(currentDate<=endDate){// Format the date ensuring we use the local date components\n// Create a new date object to avoid any timezone issues\nconst instanceDate=new Date(currentDate.getFullYear(),currentDate.getMonth(),currentDate.getDate(),12,0,0);const instanceDateStr=format(instanceDate,'yyyy-MM-dd');const instanceId=\"\".concat(task.id,\"_\").concat(instanceDateStr);console.log('RecurringTaskGenerator: Creating instance for date:',{originalCurrentDate:currentDate.toISOString(),newInstanceDate:instanceDate.toISOString(),formatted:instanceDateStr,localString:instanceDate.toLocaleDateString(),year:instanceDate.getFullYear(),month:instanceDate.getMonth()+1,day:instanceDate.getDate(),parentDeadlineWas:task.Deadline});// Check if this instance existed before and had modifications\nconst existingInstance=existingInstancesMap.get(instanceId);const hasModifications=existingInstance&&Object.keys(existingInstance.modifications||{}).length>0;// Create base task for this instance\nconst baseTask=_objectSpread(_objectSpread({},task),{},{// Override fields for instance - use the formatted date string\nDeadline:instanceDateStr,Status:this.calculateInstanceStatus(task,currentDate),Completed_x003f_:false// Default to incomplete\n});// If existing instance has modifications, preserve them but exclude status fields\nlet preservedModifications={};let preservedCompletionStatus=false;if(hasModifications){// Preserve ALL modifications including status fields (Completed_x003f_, Priority)\n// These are user actions that should persist across regenerations\npreservedModifications=_objectSpread({},existingInstance.modifications);// Preserve completion status from the instance\npreservedCompletionStatus=existingInstance.completionStatus||false;console.log('RecurringTaskGenerator: Preserving ALL modifications for instance:',instanceId,{existingModifications:existingInstance.modifications,preservedModifications:preservedModifications,completionStatus:preservedCompletionStatus});}// Create instance object\nconst instance={id:instanceId,parentId:task.id,instanceDate:instanceDateStr,// Use the formatted date string\ninstanceNumber:instanceNumber,baseTask:baseTask,completionStatus:preservedCompletionStatus,modifications:preservedModifications,createdAt:existingInstance?existingInstance.createdAt:new Date().toISOString(),lastModified:hasModifications?new Date().toISOString():new Date().toISOString()};instances.push(instance);// Move to next occurrence by adding interval months\ncurrentDate=addMonths(currentDate,interval);instanceNumber++;}console.log(\"RecurringTaskGenerator: Generated \".concat(instances.length,\" instances for task:\"),task.Task||task.id);// Store instances in IndexedDB - use updateInstance (which uses .put) to avoid conflicts\nfor(const instance of instances){try{await recurringInstanceService.updateInstance(instance);}catch(error){console.error('RecurringTaskGenerator: Failed to save instance:',instance.id,error);}}return instances.length;}/**\n   * Calculate status for an instance based on its date\n   */calculateInstanceStatus(task,instanceDate){const today=new Date();const deadline=new Date(instanceDate);// If it's a past date and not completed, it's overdue\nif(deadline<today){return'Overdue';}return'Active';}/**\n   * Generate instances for all recurring tasks\n   */async generateAllInstances(tasks){console.log('RecurringTaskGenerator: Starting generation for all tasks (recurring + non-recurring clones)');// If no tasks, clear all instances\nif(!tasks||tasks.length===0){console.log('RecurringTaskGenerator: No tasks found, clearing all instances');await recurringInstanceService.clearAllInstances();return{totalInstances:0,results:[]};}console.log('RecurringTaskGenerator: Sample task structure:',tasks[0]);console.log('RecurringTaskGenerator: All task Recurring values:',tasks.map(t=>({id:t.id,Task:t.Task,Recurring:t.Recurring,RecurringType:typeof t.Recurring})));// Separate recurring and non-recurring tasks\nconst recurringTasks=[];const nonRecurringTasks=[];tasks.forEach(task=>{const recurringValue=String(task.Recurring||'').trim();const isRecurring=recurringValue.toLowerCase()==='yes'||recurringValue.toLowerCase()==='true'||task.Recurring===true;if(isRecurring){recurringTasks.push(task);}else{nonRecurringTasks.push(task);}});console.log(\"RecurringTaskGenerator: Found \".concat(recurringTasks.length,\" recurring tasks and \").concat(nonRecurringTasks.length,\" non-recurring tasks\"));let totalInstances=0;const results=[];// Generate instances for recurring tasks\nfor(const task of recurringTasks){try{const count=await this.generateInstancesForTask(task);if(count>0){totalInstances+=count;results.push({taskId:task.id,taskName:task.Task,instanceCount:count,type:'recurring'});}}catch(error){console.error('RecurringTaskGenerator: Failed to generate instances for recurring task:',task.id,error);results.push({taskId:task.id,taskName:task.Task,error:error.message,type:'recurring'});}}// Generate clones for non-recurring tasks\nfor(const task of nonRecurringTasks){try{await this.generateNonRecurringClone(task);totalInstances+=1;results.push({taskId:task.id,taskName:task.Task,instanceCount:1,type:'non-recurring-clone'});}catch(error){console.error('RecurringTaskGenerator: Failed to generate clone for non-recurring task:',task.id,error);results.push({taskId:task.id,taskName:task.Task,error:error.message,type:'non-recurring-clone'});}}console.log(\"RecurringTaskGenerator: Generated \".concat(totalInstances,\" total instances (including non-recurring clones)\"));return{totalInstances,results};}/**\n   * Generate a single clone for a non-recurring task\n   * This allows non-recurring tasks to appear in the sub-database as working copies\n   */async generateNonRecurringClone(task){console.log('RecurringTaskGenerator: Creating clone for non-recurring task:',task.Task||task.id);// Parse the deadline\nconst deadline=this.parseDeadlineDate(task.Deadline);if(!deadline){console.log('RecurringTaskGenerator: No valid deadline for task, skipping clone');return 0;}const instanceDateStr=format(deadline,'yyyy-MM-dd');const instanceId=\"\".concat(task.id,\"_clone\");// Check if clone already exists\nconst existingInstances=await recurringInstanceService.getInstancesByParent(task.id);const existingClone=existingInstances.find(inst=>inst.id===instanceId);// Create the base task (clone of the parent)\nconst baseTask=_objectSpread(_objectSpread({},task),{},{Deadline:instanceDateStr,Status:this.calculateInstanceStatus(task,deadline),Completed_x003f_:task.Completed_x003f_||false});// Preserve modifications if clone exists\nlet preservedModifications={};let preservedCompletionStatus=false;if(existingClone){// Preserve ALL modifications including status fields (Completed_x003f_, Priority)\n// These are user actions that should persist across regenerations\npreservedModifications=_objectSpread({},existingClone.modifications);preservedCompletionStatus=existingClone.completionStatus||false;console.log('RecurringTaskGenerator: Preserving ALL modifications for non-recurring clone:',instanceId,preservedModifications);}// Create the clone instance\nconst instance={id:instanceId,parentId:task.id,instanceDate:instanceDateStr,instanceNumber:0,// Non-recurring tasks have instance number 0\nbaseTask:baseTask,completionStatus:preservedCompletionStatus,modifications:preservedModifications,createdAt:existingClone?existingClone.createdAt:new Date().toISOString(),lastModified:existingClone?new Date().toISOString():new Date().toISOString(),isNonRecurringClone:true// Flag to identify non-recurring clones\n};await recurringInstanceService.updateInstance(instance);console.log('RecurringTaskGenerator: Created/updated clone for non-recurring task:',instanceId);return 1;}/**\n   * Cascade parent task changes to all instances\n   * Updates all instances with new parent data EXCEPT Completed_x003f_, Priority, and deletion status\n   */async cascadeParentChanges(parentTask){console.log('RecurringTaskGenerator: Cascading parent changes to instances for:',parentTask.Task||parentTask.id);// Get all instances for this parent\nconst instances=await recurringInstanceService.getInstancesByParent(parentTask.id);console.log(\"RecurringTaskGenerator: Found \".concat(instances.length,\" instances to update\"));if(instances.length===0)return;// Update each instance's baseTask with new parent data\n// BUT preserve their individual modifications for Completed_x003f_, Priority\nfor(const instance of instances){// Create updated baseTask from parent, but preserve instance-specific fields\nconst updatedBaseTask=_objectSpread(_objectSpread({},parentTask),{},{// Preserve the instance's specific deadline\nDeadline:instance.instanceDate,// CRITICAL: Don't cascade Completed or Priority - keep original baseTask values\nCompleted_x003f_:instance.baseTask.Completed_x003f_,Priority:instance.baseTask.Priority});const updatedInstance=_objectSpread(_objectSpread({},instance),{},{baseTask:updatedBaseTask,lastModified:new Date().toISOString()});console.log('RecurringTaskGenerator: Updating instance',instance.id,'with new parent data, preserving Completed/Priority');await recurringInstanceService.updateInstance(updatedInstance);}console.log('RecurringTaskGenerator: Cascade complete for',instances.length,'instances');}/**\n   * Update instances when a recurring task is modified\n   */async updateTaskInstances(task){console.log('RecurringTaskGenerator: Updating instances for modified task:',task.Task||task.id);console.log('RecurringTaskGenerator: Task Recurring field:',task.Recurring,typeof task.Recurring);const recurringValue=String(task.Recurring||'').trim();const isRecurring=recurringValue.toLowerCase()==='yes'||recurringValue.toLowerCase()==='true'||task.Recurring===true;if(isRecurring){// Regenerate instances for this task\nawait this.generateInstancesForTask(task);}else{// Task is no longer recurring, delete all instances\nawait recurringInstanceService.deleteInstancesByParent(task.id);}}/**\n   * Delete instances when a task is deleted\n   */async deleteTaskInstances(taskId){console.log('RecurringTaskGenerator: Deleting instances for deleted task:',taskId);await recurringInstanceService.deleteInstancesByParent(taskId);}/**\n   * Get all instances combined with base tasks\n   */async getAllTaskInstances(){const instances=await recurringInstanceService.getAllInstances();// Convert instances to task format for compatibility with existing code\nreturn instances.map(instance=>_objectSpread(_objectSpread({},instance.baseTask),{},{id:instance.id,// Use instance ID instead of parent ID\noriginalId:instance.parentId,// Keep reference to original task\nisInstance:true,// Flag to identify instances\ninstanceDate:instance.instanceDate,instanceNumber:instance.instanceNumber,completionStatus:instance.completionStatus,modifications:instance.modifications,createdAt:instance.createdAt,lastModified:instance.lastModified},instance.modifications));}/**\n   * Update instance completion status\n   */async updateInstanceCompletion(instanceId,completed){const instances=await recurringInstanceService.getAllInstances();const instance=instances.find(i=>i.id===instanceId);if(instance){instance.completionStatus=completed;instance.lastModified=new Date().toISOString();// Update the modifications object instead of baseTask\ninstance.modifications=_objectSpread(_objectSpread({},instance.modifications),{},{Completed_x003f_:completed});await recurringInstanceService.updateInstance(instance);console.log('RecurringTaskGenerator: Updated instance completion:',instanceId,completed);}}/**\n   * Update instance modifications\n   */async updateInstanceModifications(instanceId,modifications){const instances=await recurringInstanceService.getAllInstances();const instance=instances.find(i=>i.id===instanceId);if(instance){instance.modifications=_objectSpread(_objectSpread({},instance.modifications),modifications);instance.lastModified=new Date().toISOString();// CRITICAL: Do NOT apply modifications to baseTask!\n// The baseTask should remain unchanged - modifications are applied on top when displaying\n// This ensures true independence of instances\nawait recurringInstanceService.updateInstance(instance);console.log('RecurringTaskGenerator: Updated instance modifications:',instanceId,modifications);}}/**\n   * Refresh all instances based on current SharePoint tasks\n   */async refreshAllInstances(tasks){console.log('RecurringTaskGenerator: Refreshing all instances with',tasks?tasks.length:0,'tasks...');try{// Only regenerate instances if tasks have actually changed\n// This prevents unnecessary regeneration that wipes out user completion status\nconst currentTasks=globalTaskStore.getTasks();// Check if tasks have changed by comparing key fields\nconst tasksChanged=this.haveTasksChanged(currentTasks,tasks);if(tasksChanged){console.log('RecurringTaskGenerator: Tasks have changed, regenerating instances...');await this.generateAllInstances(tasks);}else{console.log('RecurringTaskGenerator: No task changes detected, skipping regeneration to preserve user modifications');}console.log('RecurringTaskGenerator: Refresh completed');}catch(error){console.error('RecurringTaskGenerator: Error refreshing instances:',error);}}/**\n   * Check if tasks have changed in ways that require instance regeneration\n   */haveTasksChanged(currentTasks,newTasks){if(!currentTasks||!newTasks||currentTasks.length!==newTasks.length){console.log('RecurringTaskGenerator: Task count changed, regeneration needed');return true;}// Check each task for changes in fields that affect instances\nfor(let i=0;i<currentTasks.length;i++){const current=currentTasks[i];const updated=newTasks.find(t=>t.id===current.id);if(!updated){console.log('RecurringTaskGenerator: Task removed, regeneration needed');return true;}// Check fields that affect instance generation\nconst fieldsToCheck=['Recurring','Interval','FinalDate','Deadline','Task','Project','Notes','Link'];for(const field of fieldsToCheck){if(current[field]!==updated[field]){console.log(\"RecurringTaskGenerator: Task \".concat(current.id,\" field '\").concat(field,\"' changed from '\").concat(current[field],\"' to '\").concat(updated[field],\"', regeneration needed\"));return true;}}}return false;}}// Create singleton instance\nconst recurringTaskGenerator=new RecurringTaskGenerator();export default recurringTaskGenerator;","map":{"version":3,"names":["parse","isValid","addMonths","format","recurringInstanceService","globalTaskStore","RecurringTaskGenerator","constructor","maxYear","parseDeadlineDate","dateStr","year","month","day","includes","datePart","split","parts","length","parseInt","isNaN","Date","formats","fmt","d","setHours","parseFinalDate","generateInstancesForTask","task","console","log","Task","id","Recurring","recurringValue","String","trim","isRecurring","toLowerCase","Interval","Deadline","interval","startDate","raw","parsed","toISOString","localDate","toLocaleDateString","getFullYear","getMonth","getDate","endDate","FinalDate","maxEndDate","existingInstances","getInstancesByParent","existingInstancesMap","Map","map","inst","instances","currentDate","instanceNumber","instanceDate","instanceDateStr","instanceId","concat","originalCurrentDate","newInstanceDate","formatted","localString","parentDeadlineWas","existingInstance","get","hasModifications","Object","keys","modifications","baseTask","_objectSpread","Status","calculateInstanceStatus","Completed_x003f_","preservedModifications","preservedCompletionStatus","completionStatus","existingModifications","instance","parentId","createdAt","lastModified","push","updateInstance","error","today","deadline","generateAllInstances","tasks","clearAllInstances","totalInstances","results","t","RecurringType","recurringTasks","nonRecurringTasks","forEach","count","taskId","taskName","instanceCount","type","message","generateNonRecurringClone","existingClone","find","isNonRecurringClone","cascadeParentChanges","parentTask","updatedBaseTask","Priority","updatedInstance","updateTaskInstances","deleteInstancesByParent","deleteTaskInstances","getAllTaskInstances","getAllInstances","originalId","isInstance","updateInstanceCompletion","completed","i","updateInstanceModifications","refreshAllInstances","currentTasks","getTasks","tasksChanged","haveTasksChanged","newTasks","current","updated","fieldsToCheck","field","recurringTaskGenerator"],"sources":["/Users/nic/housing-deadlines-app/VERSION_2.2.0_BACKUP/src/recurringTaskGenerator.js"],"sourcesContent":["/**\n * Recurring Task Generator\n * Automatically generates instances from recurring tasks\n */\n\nimport { parse, isValid, addMonths, format } from 'date-fns';\nimport recurringInstanceService from './recurringInstanceService';\nimport { globalTaskStore } from './globalTaskStore';\n\nclass RecurringTaskGenerator {\n  constructor() {\n    this.maxYear = 2050;\n  }\n\n  /**\n   * Parse deadline date string to Date object\n   */\n  parseDeadlineDate(dateStr) {\n    if (!dateStr) return null;\n    \n    // Extract date components to avoid timezone issues\n    let year, month, day;\n    \n    // Try ISO format first (SharePoint format: 2024-10-09T00:00:00Z or 2024-10-09)\n    if (typeof dateStr === 'string' && dateStr.includes('-')) {\n      const datePart = dateStr.split('T')[0]; // Get just the date part\n      const parts = datePart.split('-');\n      if (parts.length === 3) {\n        year = parseInt(parts[0], 10);\n        month = parseInt(parts[1], 10) - 1; // JS months are 0-indexed\n        day = parseInt(parts[2], 10);\n        \n        if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {\n          // Create date at noon local time to avoid timezone shifts\n          return new Date(year, month, day, 12, 0, 0);\n        }\n      }\n    }\n    \n    // Try explicit formats with date-fns as fallback\n    const formats = [\n      'MM/dd/yyyy',\n      'M/d/yy',\n      'M/d/yyyy',\n      'MM/dd/yy',\n    ];\n    \n    for (const fmt of formats) {\n      const d = parse(dateStr, fmt, new Date());\n      if (isValid(d)) {\n        // Set to noon to avoid timezone issues\n        d.setHours(12, 0, 0, 0);\n        return d;\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Parse final date string to Date object\n   */\n  parseFinalDate(dateStr) {\n    if (!dateStr) return null;\n    return this.parseDeadlineDate(dateStr);\n  }\n\n  /**\n   * Generate instances for a single recurring task\n   */\n  async generateInstancesForTask(task) {\n    console.log('RecurringTaskGenerator: Generating instances for task:', task.Task || task.id);\n    console.log('RecurringTaskGenerator: Task Recurring field:', task.Recurring, typeof task.Recurring);\n    \n    // Check if task is recurring - handle various formats\n    const recurringValue = String(task.Recurring || '').trim();\n    const isRecurring = recurringValue.toLowerCase() === 'yes' || \n                       recurringValue.toLowerCase() === 'true' ||\n                       task.Recurring === true;\n    console.log('RecurringTaskGenerator: Task Recurring field:', task.Recurring, typeof task.Recurring, 'normalized:', recurringValue, 'isRecurring:', isRecurring);\n    if (!isRecurring) {\n      console.log('RecurringTaskGenerator: Task is not recurring (Recurring field is not \"Yes\" or \"True\"), skipping');\n      return;\n    }\n\n    // Validate required fields\n    if (!task.Interval || !task.Deadline) {\n      console.log('RecurringTaskGenerator: Missing required fields (Interval or Deadline)');\n      return;\n    }\n\n    const interval = parseInt(task.Interval, 10);\n    if (isNaN(interval) || interval < 1) {\n      console.log('RecurringTaskGenerator: Invalid interval:', task.Interval);\n      return;\n    }\n\n    const startDate = this.parseDeadlineDate(task.Deadline);\n    if (!startDate) {\n      console.log('RecurringTaskGenerator: Invalid start date:', task.Deadline);\n      return;\n    }\n    \n    console.log('RecurringTaskGenerator: Parsed deadline:', {\n      raw: task.Deadline,\n      parsed: startDate.toISOString(),\n      localDate: startDate.toLocaleDateString(),\n      year: startDate.getFullYear(),\n      month: startDate.getMonth() + 1,\n      day: startDate.getDate()\n    });\n\n    // Determine end date\n    let endDate;\n    if (task.FinalDate) {\n      endDate = this.parseFinalDate(task.FinalDate);\n      if (!endDate) {\n        // If finalDate is invalid, use maxYear\n        endDate = new Date(this.maxYear, 11, 31);\n      }\n    } else {\n      // No finalDate specified, use maxYear\n      endDate = new Date(this.maxYear, 11, 31);\n    }\n\n    // Ensure endDate doesn't exceed maxYear\n    const maxEndDate = new Date(this.maxYear, 11, 31);\n    if (endDate > maxEndDate) {\n      endDate = maxEndDate;\n    }\n\n    console.log('RecurringTaskGenerator: Generating instances from', format(startDate, 'yyyy-MM-dd'), 'to', format(endDate, 'yyyy-MM-dd'));\n\n    // Get existing instances to preserve modifications\n    const existingInstances = await recurringInstanceService.getInstancesByParent(task.id);\n    const existingInstancesMap = new Map(existingInstances.map(inst => [inst.id, inst]));\n    console.log('RecurringTaskGenerator: Found', existingInstances.length, 'existing instances with modifications to preserve');\n\n    // Generate instances starting from the FIRST occurrence (the parent's date)\n    // This creates a \"current year clone\" in the sub-database so users can work with it\n    const instances = [];\n    let currentDate = new Date(startDate); // Start from the parent's date, not the next recurrence\n    let instanceNumber = 0; // Start from 0 so first instance is labeled correctly\n\n    while (currentDate <= endDate) {\n\n      // Format the date ensuring we use the local date components\n      // Create a new date object to avoid any timezone issues\n      const instanceDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), 12, 0, 0);\n      const instanceDateStr = format(instanceDate, 'yyyy-MM-dd');\n      const instanceId = `${task.id}_${instanceDateStr}`;\n      \n      console.log('RecurringTaskGenerator: Creating instance for date:', {\n        originalCurrentDate: currentDate.toISOString(),\n        newInstanceDate: instanceDate.toISOString(),\n        formatted: instanceDateStr,\n        localString: instanceDate.toLocaleDateString(),\n        year: instanceDate.getFullYear(),\n        month: instanceDate.getMonth() + 1,\n        day: instanceDate.getDate(),\n        parentDeadlineWas: task.Deadline\n      });\n      \n      // Check if this instance existed before and had modifications\n      const existingInstance = existingInstancesMap.get(instanceId);\n      const hasModifications = existingInstance && Object.keys(existingInstance.modifications || {}).length > 0;\n      \n      // Create base task for this instance\n      const baseTask = {\n        ...task,\n        // Override fields for instance - use the formatted date string\n        Deadline: instanceDateStr,\n        Status: this.calculateInstanceStatus(task, currentDate),\n        Completed_x003f_: false // Default to incomplete\n      };\n      \n      // If existing instance has modifications, preserve them but exclude status fields\n      let preservedModifications = {};\n      let preservedCompletionStatus = false;\n      \n      if (hasModifications) {\n        // Preserve ALL modifications including status fields (Completed_x003f_, Priority)\n        // These are user actions that should persist across regenerations\n        preservedModifications = { ...existingInstance.modifications };\n        \n        // Preserve completion status from the instance\n        preservedCompletionStatus = existingInstance.completionStatus || false;\n        \n        console.log('RecurringTaskGenerator: Preserving ALL modifications for instance:', instanceId, {\n          existingModifications: existingInstance.modifications,\n          preservedModifications: preservedModifications,\n          completionStatus: preservedCompletionStatus\n        });\n      }\n      \n      // Create instance object\n      const instance = {\n        id: instanceId,\n        parentId: task.id,\n        instanceDate: instanceDateStr, // Use the formatted date string\n        instanceNumber: instanceNumber,\n        baseTask: baseTask,\n        completionStatus: preservedCompletionStatus,\n        modifications: preservedModifications,\n        createdAt: existingInstance ? existingInstance.createdAt : new Date().toISOString(),\n        lastModified: hasModifications ? new Date().toISOString() : new Date().toISOString()\n      };\n\n      instances.push(instance);\n      \n      // Move to next occurrence by adding interval months\n      currentDate = addMonths(currentDate, interval);\n      instanceNumber++;\n    }\n\n    console.log(`RecurringTaskGenerator: Generated ${instances.length} instances for task:`, task.Task || task.id);\n\n    // Store instances in IndexedDB - use updateInstance (which uses .put) to avoid conflicts\n    for (const instance of instances) {\n      try {\n        await recurringInstanceService.updateInstance(instance);\n      } catch (error) {\n        console.error('RecurringTaskGenerator: Failed to save instance:', instance.id, error);\n      }\n    }\n\n    return instances.length;\n  }\n\n  /**\n   * Calculate status for an instance based on its date\n   */\n  calculateInstanceStatus(task, instanceDate) {\n    const today = new Date();\n    const deadline = new Date(instanceDate);\n    \n    // If it's a past date and not completed, it's overdue\n    if (deadline < today) {\n      return 'Overdue';\n    }\n    \n    return 'Active';\n  }\n\n  /**\n   * Generate instances for all recurring tasks\n   */\n  async generateAllInstances(tasks) {\n    console.log('RecurringTaskGenerator: Starting generation for all tasks (recurring + non-recurring clones)');\n    \n    // If no tasks, clear all instances\n    if (!tasks || tasks.length === 0) {\n      console.log('RecurringTaskGenerator: No tasks found, clearing all instances');\n      await recurringInstanceService.clearAllInstances();\n      return { totalInstances: 0, results: [] };\n    }\n\n    console.log('RecurringTaskGenerator: Sample task structure:', tasks[0]);\n    console.log('RecurringTaskGenerator: All task Recurring values:', tasks.map(t => ({ id: t.id, Task: t.Task, Recurring: t.Recurring, RecurringType: typeof t.Recurring })));\n    \n    // Separate recurring and non-recurring tasks\n    const recurringTasks = [];\n    const nonRecurringTasks = [];\n    \n    tasks.forEach(task => {\n      const recurringValue = String(task.Recurring || '').trim();\n      const isRecurring = recurringValue.toLowerCase() === 'yes' || \n                         recurringValue.toLowerCase() === 'true' ||\n                         task.Recurring === true;\n      \n      if (isRecurring) {\n        recurringTasks.push(task);\n      } else {\n        nonRecurringTasks.push(task);\n      }\n    });\n    \n    console.log(`RecurringTaskGenerator: Found ${recurringTasks.length} recurring tasks and ${nonRecurringTasks.length} non-recurring tasks`);\n\n    let totalInstances = 0;\n    const results = [];\n\n    // Generate instances for recurring tasks\n    for (const task of recurringTasks) {\n      try {\n        const count = await this.generateInstancesForTask(task);\n        if (count > 0) {\n          totalInstances += count;\n          results.push({ taskId: task.id, taskName: task.Task, instanceCount: count, type: 'recurring' });\n        }\n      } catch (error) {\n        console.error('RecurringTaskGenerator: Failed to generate instances for recurring task:', task.id, error);\n        results.push({ taskId: task.id, taskName: task.Task, error: error.message, type: 'recurring' });\n      }\n    }\n    \n    // Generate clones for non-recurring tasks\n    for (const task of nonRecurringTasks) {\n      try {\n        await this.generateNonRecurringClone(task);\n        totalInstances += 1;\n        results.push({ taskId: task.id, taskName: task.Task, instanceCount: 1, type: 'non-recurring-clone' });\n      } catch (error) {\n        console.error('RecurringTaskGenerator: Failed to generate clone for non-recurring task:', task.id, error);\n        results.push({ taskId: task.id, taskName: task.Task, error: error.message, type: 'non-recurring-clone' });\n      }\n    }\n\n    console.log(`RecurringTaskGenerator: Generated ${totalInstances} total instances (including non-recurring clones)`);\n    return { totalInstances, results };\n  }\n  \n  /**\n   * Generate a single clone for a non-recurring task\n   * This allows non-recurring tasks to appear in the sub-database as working copies\n   */\n  async generateNonRecurringClone(task) {\n    console.log('RecurringTaskGenerator: Creating clone for non-recurring task:', task.Task || task.id);\n    \n    // Parse the deadline\n    const deadline = this.parseDeadlineDate(task.Deadline);\n    if (!deadline) {\n      console.log('RecurringTaskGenerator: No valid deadline for task, skipping clone');\n      return 0;\n    }\n    \n    const instanceDateStr = format(deadline, 'yyyy-MM-dd');\n    const instanceId = `${task.id}_clone`;\n    \n    // Check if clone already exists\n    const existingInstances = await recurringInstanceService.getInstancesByParent(task.id);\n    const existingClone = existingInstances.find(inst => inst.id === instanceId);\n    \n    // Create the base task (clone of the parent)\n    const baseTask = {\n      ...task,\n      Deadline: instanceDateStr,\n      Status: this.calculateInstanceStatus(task, deadline),\n      Completed_x003f_: task.Completed_x003f_ || false\n    };\n    \n    // Preserve modifications if clone exists\n    let preservedModifications = {};\n    let preservedCompletionStatus = false;\n    \n    if (existingClone) {\n      // Preserve ALL modifications including status fields (Completed_x003f_, Priority)\n      // These are user actions that should persist across regenerations\n      preservedModifications = { ...existingClone.modifications };\n      preservedCompletionStatus = existingClone.completionStatus || false;\n      \n      console.log('RecurringTaskGenerator: Preserving ALL modifications for non-recurring clone:', instanceId, preservedModifications);\n    }\n    \n    // Create the clone instance\n    const instance = {\n      id: instanceId,\n      parentId: task.id,\n      instanceDate: instanceDateStr,\n      instanceNumber: 0, // Non-recurring tasks have instance number 0\n      baseTask: baseTask,\n      completionStatus: preservedCompletionStatus,\n      modifications: preservedModifications,\n      createdAt: existingClone ? existingClone.createdAt : new Date().toISOString(),\n      lastModified: existingClone ? new Date().toISOString() : new Date().toISOString(),\n      isNonRecurringClone: true // Flag to identify non-recurring clones\n    };\n    \n    await recurringInstanceService.updateInstance(instance);\n    console.log('RecurringTaskGenerator: Created/updated clone for non-recurring task:', instanceId);\n    \n    return 1;\n  }\n\n  /**\n   * Cascade parent task changes to all instances\n   * Updates all instances with new parent data EXCEPT Completed_x003f_, Priority, and deletion status\n   */\n  async cascadeParentChanges(parentTask) {\n    console.log('RecurringTaskGenerator: Cascading parent changes to instances for:', parentTask.Task || parentTask.id);\n    \n    // Get all instances for this parent\n    const instances = await recurringInstanceService.getInstancesByParent(parentTask.id);\n    console.log(`RecurringTaskGenerator: Found ${instances.length} instances to update`);\n    \n    if (instances.length === 0) return;\n    \n    // Update each instance's baseTask with new parent data\n    // BUT preserve their individual modifications for Completed_x003f_, Priority\n    for (const instance of instances) {\n      // Create updated baseTask from parent, but preserve instance-specific fields\n      const updatedBaseTask = {\n        ...parentTask,\n        // Preserve the instance's specific deadline\n        Deadline: instance.instanceDate,\n        // CRITICAL: Don't cascade Completed or Priority - keep original baseTask values\n        Completed_x003f_: instance.baseTask.Completed_x003f_,\n        Priority: instance.baseTask.Priority\n      };\n      \n      const updatedInstance = {\n        ...instance,\n        baseTask: updatedBaseTask,\n        lastModified: new Date().toISOString()\n      };\n      \n      console.log('RecurringTaskGenerator: Updating instance', instance.id, 'with new parent data, preserving Completed/Priority');\n      \n      await recurringInstanceService.updateInstance(updatedInstance);\n    }\n    \n    console.log('RecurringTaskGenerator: Cascade complete for', instances.length, 'instances');\n  }\n\n  /**\n   * Update instances when a recurring task is modified\n   */\n  async updateTaskInstances(task) {\n    console.log('RecurringTaskGenerator: Updating instances for modified task:', task.Task || task.id);\n    console.log('RecurringTaskGenerator: Task Recurring field:', task.Recurring, typeof task.Recurring);\n    \n    const recurringValue = String(task.Recurring || '').trim();\n    const isRecurring = recurringValue.toLowerCase() === 'yes' || \n                       recurringValue.toLowerCase() === 'true' ||\n                       task.Recurring === true;\n    if (isRecurring) {\n      // Regenerate instances for this task\n      await this.generateInstancesForTask(task);\n    } else {\n      // Task is no longer recurring, delete all instances\n      await recurringInstanceService.deleteInstancesByParent(task.id);\n    }\n  }\n\n  /**\n   * Delete instances when a task is deleted\n   */\n  async deleteTaskInstances(taskId) {\n    console.log('RecurringTaskGenerator: Deleting instances for deleted task:', taskId);\n    await recurringInstanceService.deleteInstancesByParent(taskId);\n  }\n\n  /**\n   * Get all instances combined with base tasks\n   */\n  async getAllTaskInstances() {\n    const instances = await recurringInstanceService.getAllInstances();\n    \n    // Convert instances to task format for compatibility with existing code\n    return instances.map(instance => ({\n      ...instance.baseTask,\n      id: instance.id, // Use instance ID instead of parent ID\n      originalId: instance.parentId, // Keep reference to original task\n      isInstance: true, // Flag to identify instances\n      instanceDate: instance.instanceDate,\n      instanceNumber: instance.instanceNumber,\n      completionStatus: instance.completionStatus,\n      modifications: instance.modifications,\n      createdAt: instance.createdAt,\n      lastModified: instance.lastModified,\n      // Apply modifications on top of baseTask so changes are visible\n      ...instance.modifications\n    }));\n  }\n\n  /**\n   * Update instance completion status\n   */\n  async updateInstanceCompletion(instanceId, completed) {\n    const instances = await recurringInstanceService.getAllInstances();\n    const instance = instances.find(i => i.id === instanceId);\n    \n    if (instance) {\n      instance.completionStatus = completed;\n      instance.lastModified = new Date().toISOString();\n      \n      // Update the modifications object instead of baseTask\n      instance.modifications = {\n        ...instance.modifications,\n        Completed_x003f_: completed\n      };\n      \n      await recurringInstanceService.updateInstance(instance);\n      console.log('RecurringTaskGenerator: Updated instance completion:', instanceId, completed);\n    }\n  }\n\n  /**\n   * Update instance modifications\n   */\n  async updateInstanceModifications(instanceId, modifications) {\n    const instances = await recurringInstanceService.getAllInstances();\n    const instance = instances.find(i => i.id === instanceId);\n    \n    if (instance) {\n      instance.modifications = { ...instance.modifications, ...modifications };\n      instance.lastModified = new Date().toISOString();\n      \n      // CRITICAL: Do NOT apply modifications to baseTask!\n      // The baseTask should remain unchanged - modifications are applied on top when displaying\n      // This ensures true independence of instances\n      \n      await recurringInstanceService.updateInstance(instance);\n      console.log('RecurringTaskGenerator: Updated instance modifications:', instanceId, modifications);\n    }\n  }\n\n  /**\n   * Refresh all instances based on current SharePoint tasks\n   */\n  async refreshAllInstances(tasks) {\n    console.log('RecurringTaskGenerator: Refreshing all instances with', tasks ? tasks.length : 0, 'tasks...');\n    try {\n      // Only regenerate instances if tasks have actually changed\n      // This prevents unnecessary regeneration that wipes out user completion status\n      const currentTasks = globalTaskStore.getTasks();\n      \n      // Check if tasks have changed by comparing key fields\n      const tasksChanged = this.haveTasksChanged(currentTasks, tasks);\n      \n      if (tasksChanged) {\n        console.log('RecurringTaskGenerator: Tasks have changed, regenerating instances...');\n        await this.generateAllInstances(tasks);\n      } else {\n        console.log('RecurringTaskGenerator: No task changes detected, skipping regeneration to preserve user modifications');\n      }\n      \n      console.log('RecurringTaskGenerator: Refresh completed');\n    } catch (error) {\n      console.error('RecurringTaskGenerator: Error refreshing instances:', error);\n    }\n  }\n  \n  /**\n   * Check if tasks have changed in ways that require instance regeneration\n   */\n  haveTasksChanged(currentTasks, newTasks) {\n    if (!currentTasks || !newTasks || currentTasks.length !== newTasks.length) {\n      console.log('RecurringTaskGenerator: Task count changed, regeneration needed');\n      return true;\n    }\n    \n    // Check each task for changes in fields that affect instances\n    for (let i = 0; i < currentTasks.length; i++) {\n      const current = currentTasks[i];\n      const updated = newTasks.find(t => t.id === current.id);\n      \n      if (!updated) {\n        console.log('RecurringTaskGenerator: Task removed, regeneration needed');\n        return true;\n      }\n      \n      // Check fields that affect instance generation\n      const fieldsToCheck = ['Recurring', 'Interval', 'FinalDate', 'Deadline', 'Task', 'Project', 'Notes', 'Link'];\n      for (const field of fieldsToCheck) {\n        if (current[field] !== updated[field]) {\n          console.log(`RecurringTaskGenerator: Task ${current.id} field '${field}' changed from '${current[field]}' to '${updated[field]}', regeneration needed`);\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n}\n\n// Create singleton instance\nconst recurringTaskGenerator = new RecurringTaskGenerator();\n\nexport default recurringTaskGenerator;\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}