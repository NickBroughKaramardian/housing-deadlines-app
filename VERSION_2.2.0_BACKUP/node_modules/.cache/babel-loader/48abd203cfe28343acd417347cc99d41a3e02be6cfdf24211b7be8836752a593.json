{"ast":null,"code":"/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\nimport { __awaiter } from \"tslib\";\nimport { RequestMethod } from \"../RequestMethod\";\nimport { MiddlewareControl } from \"./MiddlewareControl\";\nimport { getRequestHeader, setRequestHeader } from \"./MiddlewareUtil\";\nimport { RetryHandlerOptions } from \"./options/RetryHandlerOptions\";\nimport { FeatureUsageFlag, TelemetryHandlerOptions } from \"./options/TelemetryHandlerOptions\";\n/**\n * @class\n * @implements Middleware\n * Class for RetryHandler\n */\nexport class RetryHandler {\n  /**\n   * @public\n   * @constructor\n   * To create an instance of RetryHandler\n   * @param {RetryHandlerOptions} [options = new RetryHandlerOptions()] - The retry handler options value\n   * @returns An instance of RetryHandler\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new RetryHandlerOptions();\n    this.options = options;\n  }\n  /**\n   *\n   * @private\n   * To check whether the response has the retry status code\n   * @param {Response} response - The response object\n   * @returns Whether the response has retry status code or not\n   */\n  isRetry(response) {\n    return RetryHandler.RETRY_STATUS_CODES.indexOf(response.status) !== -1;\n  }\n  /**\n   * @private\n   * To check whether the payload is buffered or not\n   * @param {RequestInfo} request - The url string or the request object value\n   * @param {FetchOptions} options - The options of a request\n   * @returns Whether the payload is buffered or not\n   */\n  isBuffered(request, options) {\n    const method = typeof request === \"string\" ? options.method : request.method;\n    const isPutPatchOrPost = method === RequestMethod.PUT || method === RequestMethod.PATCH || method === RequestMethod.POST;\n    if (isPutPatchOrPost) {\n      const isStream = getRequestHeader(request, options, \"Content-Type\") === \"application/octet-stream\";\n      if (isStream) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * @private\n   * To get the delay for a retry\n   * @param {Response} response - The response object\n   * @param {number} retryAttempts - The current attempt count\n   * @param {number} delay - The delay value in seconds\n   * @returns A delay for a retry\n   */\n  getDelay(response, retryAttempts, delay) {\n    const getRandomness = () => Number(Math.random().toFixed(3));\n    const retryAfter = response.headers !== undefined ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;\n    let newDelay;\n    if (retryAfter !== null) {\n      if (Number.isNaN(Number(retryAfter))) {\n        newDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1000);\n      } else {\n        newDelay = Number(retryAfter);\n      }\n    } else {\n      // Adding randomness to avoid retrying at a same\n      newDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay + getRandomness() : delay + getRandomness();\n    }\n    return Math.min(newDelay, this.options.getMaxDelay() + getRandomness());\n  }\n  /**\n   * @private\n   * To get an exponential back off value\n   * @param {number} attempts - The current attempt count\n   * @returns An exponential back off value\n   */\n  getExponentialBackOffTime(attempts) {\n    return Math.round(1 / 2 * (Math.pow(2, attempts) - 1));\n  }\n  /**\n   * @private\n   * @async\n   * To add delay for the execution\n   * @param {number} delaySeconds - The delay value in seconds\n   * @returns Nothing\n   */\n  sleep(delaySeconds) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const delayMilliseconds = delaySeconds * 1000;\n      return new Promise(resolve => setTimeout(resolve, delayMilliseconds));\n    });\n  }\n  getOptions(context) {\n    let options;\n    if (context.middlewareControl instanceof MiddlewareControl) {\n      options = context.middlewareControl.getMiddlewareOptions(this.options.constructor);\n    }\n    if (typeof options === \"undefined\") {\n      options = Object.assign(new RetryHandlerOptions(), this.options);\n    }\n    return options;\n  }\n  /**\n   * @private\n   * @async\n   * To execute the middleware with retries\n   * @param {Context} context - The context object\n   * @param {number} retryAttempts - The current attempt count\n   * @param {RetryHandlerOptions} options - The retry middleware options instance\n   * @returns A Promise that resolves to nothing\n   */\n  executeWithRetry(context, retryAttempts, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.nextMiddleware.execute(context);\n      if (retryAttempts < options.maxRetries && this.isRetry(context.response) && this.isBuffered(context.request, context.options) && options.shouldRetry(options.delay, retryAttempts, context.request, context.options, context.response)) {\n        ++retryAttempts;\n        setRequestHeader(context.request, context.options, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());\n        const delay = this.getDelay(context.response, retryAttempts, options.delay);\n        yield this.sleep(delay);\n        return yield this.executeWithRetry(context, retryAttempts, options);\n      } else {\n        return;\n      }\n    });\n  }\n  /**\n   * @public\n   * @async\n   * To execute the current middleware\n   * @param {Context} context - The context object of the request\n   * @returns A Promise that resolves to nothing\n   */\n  execute(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const retryAttempts = 0;\n      const options = this.getOptions(context);\n      TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.RETRY_HANDLER_ENABLED);\n      return yield this.executeWithRetry(context, retryAttempts, options);\n    });\n  }\n  /**\n   * @public\n   * To set the next middleware in the chain\n   * @param {Middleware} next - The middleware instance\n   * @returns Nothing\n   */\n  setNext(next) {\n    this.nextMiddleware = next;\n  }\n}\n/**\n * @private\n * @static\n * A list of status codes that needs to be retried\n */\nRetryHandler.RETRY_STATUS_CODES = [429, 503, 504 // Gateway timeout\n];\n/**\n * @private\n * @static\n * A member holding the name of retry attempt header\n */\nRetryHandler.RETRY_ATTEMPT_HEADER = \"Retry-Attempt\";\n/**\n * @private\n * @static\n * A member holding the name of retry after header\n */\nRetryHandler.RETRY_AFTER_HEADER = \"Retry-After\";","map":{"version":3,"names":["RequestMethod","MiddlewareControl","getRequestHeader","setRequestHeader","RetryHandlerOptions","FeatureUsageFlag","TelemetryHandlerOptions","RetryHandler","constructor","options","arguments","length","undefined","isRetry","response","RETRY_STATUS_CODES","indexOf","status","isBuffered","request","method","isPutPatchOrPost","PUT","PATCH","POST","isStream","getDelay","retryAttempts","delay","getRandomness","Number","Math","random","toFixed","retryAfter","headers","get","RETRY_AFTER_HEADER","newDelay","isNaN","round","Date","getTime","now","getExponentialBackOffTime","min","getMaxDelay","attempts","pow","sleep","delaySeconds","delayMilliseconds","Promise","resolve","setTimeout","getOptions","context","middlewareControl","getMiddlewareOptions","Object","assign","executeWithRetry","nextMiddleware","execute","maxRetries","shouldRetry","RETRY_ATTEMPT_HEADER","toString","updateFeatureUsageFlag","RETRY_HANDLER_ENABLED","setNext","next"],"sources":["/Users/nic/housing-deadlines-app/node_modules/@microsoft/microsoft-graph-client/src/middleware/RetryHandler.ts"],"sourcesContent":["/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module RetryHandler\n */\n\nimport { Context } from \"../IContext\";\nimport { FetchOptions } from \"../IFetchOptions\";\nimport { RequestMethod } from \"../RequestMethod\";\nimport { Middleware } from \"./IMiddleware\";\nimport { MiddlewareControl } from \"./MiddlewareControl\";\nimport { getRequestHeader, setRequestHeader } from \"./MiddlewareUtil\";\nimport { RetryHandlerOptions } from \"./options/RetryHandlerOptions\";\nimport { FeatureUsageFlag, TelemetryHandlerOptions } from \"./options/TelemetryHandlerOptions\";\n\n/**\n * @class\n * @implements Middleware\n * Class for RetryHandler\n */\nexport class RetryHandler implements Middleware {\n\t/**\n\t * @private\n\t * @static\n\t * A list of status codes that needs to be retried\n\t */\n\tprivate static RETRY_STATUS_CODES: number[] = [\n\t\t429, // Too many requests\n\t\t503, // Service unavailable\n\t\t504, // Gateway timeout\n\t];\n\n\t/**\n\t * @private\n\t * @static\n\t * A member holding the name of retry attempt header\n\t */\n\tprivate static RETRY_ATTEMPT_HEADER = \"Retry-Attempt\";\n\n\t/**\n\t * @private\n\t * @static\n\t * A member holding the name of retry after header\n\t */\n\tprivate static RETRY_AFTER_HEADER = \"Retry-After\";\n\n\t/**\n\t * @private\n\t * A member to hold next middleware in the middleware chain\n\t */\n\tprivate nextMiddleware: Middleware;\n\n\t/**\n\t * @private\n\t * A member holding the retry handler options\n\t */\n\tprivate options: RetryHandlerOptions;\n\n\t/**\n\t * @public\n\t * @constructor\n\t * To create an instance of RetryHandler\n\t * @param {RetryHandlerOptions} [options = new RetryHandlerOptions()] - The retry handler options value\n\t * @returns An instance of RetryHandler\n\t */\n\tpublic constructor(options: RetryHandlerOptions = new RetryHandlerOptions()) {\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t *\n\t * @private\n\t * To check whether the response has the retry status code\n\t * @param {Response} response - The response object\n\t * @returns Whether the response has retry status code or not\n\t */\n\tprivate isRetry(response: Response): boolean {\n\t\treturn RetryHandler.RETRY_STATUS_CODES.indexOf(response.status) !== -1;\n\t}\n\n\t/**\n\t * @private\n\t * To check whether the payload is buffered or not\n\t * @param {RequestInfo} request - The url string or the request object value\n\t * @param {FetchOptions} options - The options of a request\n\t * @returns Whether the payload is buffered or not\n\t */\n\tprivate isBuffered(request: RequestInfo, options: FetchOptions | undefined): boolean {\n\t\tconst method = typeof request === \"string\" ? options.method : (request as Request).method;\n\t\tconst isPutPatchOrPost: boolean = method === RequestMethod.PUT || method === RequestMethod.PATCH || method === RequestMethod.POST;\n\t\tif (isPutPatchOrPost) {\n\t\t\tconst isStream = getRequestHeader(request, options, \"Content-Type\") === \"application/octet-stream\";\n\t\t\tif (isStream) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @private\n\t * To get the delay for a retry\n\t * @param {Response} response - The response object\n\t * @param {number} retryAttempts - The current attempt count\n\t * @param {number} delay - The delay value in seconds\n\t * @returns A delay for a retry\n\t */\n\tprivate getDelay(response: Response, retryAttempts: number, delay: number): number {\n\t\tconst getRandomness = () => Number(Math.random().toFixed(3));\n\t\tconst retryAfter = response.headers !== undefined ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;\n\t\tlet newDelay: number;\n\t\tif (retryAfter !== null) {\n\t\t\tif (Number.isNaN(Number(retryAfter))) {\n\t\t\t\tnewDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1000);\n\t\t\t} else {\n\t\t\t\tnewDelay = Number(retryAfter);\n\t\t\t}\n\t\t} else {\n\t\t\t// Adding randomness to avoid retrying at a same\n\t\t\tnewDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay + getRandomness() : delay + getRandomness();\n\t\t}\n\t\treturn Math.min(newDelay, this.options.getMaxDelay() + getRandomness());\n\t}\n\n\t/**\n\t * @private\n\t * To get an exponential back off value\n\t * @param {number} attempts - The current attempt count\n\t * @returns An exponential back off value\n\t */\n\tprivate getExponentialBackOffTime(attempts: number): number {\n\t\treturn Math.round((1 / 2) * (2 ** attempts - 1));\n\t}\n\n\t/**\n\t * @private\n\t * @async\n\t * To add delay for the execution\n\t * @param {number} delaySeconds - The delay value in seconds\n\t * @returns Nothing\n\t */\n\tprivate async sleep(delaySeconds: number): Promise<void> {\n\t\tconst delayMilliseconds = delaySeconds * 1000;\n\t\treturn new Promise((resolve) => setTimeout(resolve, delayMilliseconds));\n\t}\n\n\tprivate getOptions(context: Context): RetryHandlerOptions {\n\t\tlet options: RetryHandlerOptions;\n\t\tif (context.middlewareControl instanceof MiddlewareControl) {\n\t\t\toptions = context.middlewareControl.getMiddlewareOptions(this.options.constructor) as RetryHandlerOptions;\n\t\t}\n\t\tif (typeof options === \"undefined\") {\n\t\t\toptions = Object.assign(new RetryHandlerOptions(), this.options);\n\t\t}\n\t\treturn options;\n\t}\n\n\t/**\n\t * @private\n\t * @async\n\t * To execute the middleware with retries\n\t * @param {Context} context - The context object\n\t * @param {number} retryAttempts - The current attempt count\n\t * @param {RetryHandlerOptions} options - The retry middleware options instance\n\t * @returns A Promise that resolves to nothing\n\t */\n\tprivate async executeWithRetry(context: Context, retryAttempts: number, options: RetryHandlerOptions): Promise<void> {\n\t\tawait this.nextMiddleware.execute(context);\n\t\tif (retryAttempts < options.maxRetries && this.isRetry(context.response) && this.isBuffered(context.request, context.options) && options.shouldRetry(options.delay, retryAttempts, context.request, context.options, context.response)) {\n\t\t\t++retryAttempts;\n\t\t\tsetRequestHeader(context.request, context.options, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());\n\t\t\tconst delay = this.getDelay(context.response, retryAttempts, options.delay);\n\t\t\tawait this.sleep(delay);\n\t\t\treturn await this.executeWithRetry(context, retryAttempts, options);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * @public\n\t * @async\n\t * To execute the current middleware\n\t * @param {Context} context - The context object of the request\n\t * @returns A Promise that resolves to nothing\n\t */\n\tpublic async execute(context: Context): Promise<void> {\n\t\tconst retryAttempts = 0;\n\t\tconst options: RetryHandlerOptions = this.getOptions(context);\n\t\tTelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.RETRY_HANDLER_ENABLED);\n\t\treturn await this.executeWithRetry(context, retryAttempts, options);\n\t}\n\n\t/**\n\t * @public\n\t * To set the next middleware in the chain\n\t * @param {Middleware} next - The middleware instance\n\t * @returns Nothing\n\t */\n\tpublic setNext(next: Middleware): void {\n\t\tthis.nextMiddleware = next;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}