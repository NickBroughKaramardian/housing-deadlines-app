{"ast":null,"code":"/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\nimport { __awaiter } from \"tslib\";\nimport { ResponseType } from \"./ResponseType\";\n/**\n * @enum\n * Enum for document types\n * @property {string} TEXT_HTML - The text/html content type\n * @property {string} TEXT_XML - The text/xml content type\n * @property {string} APPLICATION_XML - The application/xml content type\n * @property {string} APPLICATION_XHTML - The application/xhml+xml content type\n */\nexport var DocumentType;\n(function (DocumentType) {\n  DocumentType[\"TEXT_HTML\"] = \"text/html\";\n  DocumentType[\"TEXT_XML\"] = \"text/xml\";\n  DocumentType[\"APPLICATION_XML\"] = \"application/xml\";\n  DocumentType[\"APPLICATION_XHTML\"] = \"application/xhtml+xml\";\n})(DocumentType || (DocumentType = {}));\n/**\n * @enum\n * Enum for Content types\n * @property {string} TEXT_PLAIN - The text/plain content type\n * @property {string} APPLICATION_JSON - The application/json content type\n */\nvar ContentType;\n(function (ContentType) {\n  ContentType[\"TEXT_PLAIN\"] = \"text/plain\";\n  ContentType[\"APPLICATION_JSON\"] = \"application/json\";\n})(ContentType || (ContentType = {}));\n/**\n * @enum\n * Enum for Content type regex\n * @property {string} DOCUMENT - The regex to match document content types\n * @property {string} IMAGE - The regex to match image content types\n */\nvar ContentTypeRegexStr;\n(function (ContentTypeRegexStr) {\n  ContentTypeRegexStr[\"DOCUMENT\"] = \"^(text\\\\/(html|xml))|(application\\\\/(xml|xhtml\\\\+xml))$\";\n  ContentTypeRegexStr[\"IMAGE\"] = \"^image\\\\/.+\";\n})(ContentTypeRegexStr || (ContentTypeRegexStr = {}));\n/**\n * @class\n * Class for GraphResponseHandler\n */\nexport class GraphResponseHandler {\n  /**\n   * @private\n   * @static\n   * To parse Document response\n   * @param {Response} rawResponse - The response object\n   * @param {DocumentType} type - The type to which the document needs to be parsed\n   * @returns A promise that resolves to a document content\n   */\n  static parseDocumentResponse(rawResponse, type) {\n    if (typeof DOMParser !== \"undefined\") {\n      return new Promise((resolve, reject) => {\n        rawResponse.text().then(xmlString => {\n          try {\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(xmlString, type);\n            resolve(xmlDoc);\n          } catch (error) {\n            reject(error);\n          }\n        });\n      });\n    } else {\n      return Promise.resolve(rawResponse.body);\n    }\n  }\n  /**\n   * @private\n   * @static\n   * @async\n   * To convert the native Response to response content\n   * @param {Response} rawResponse - The response object\n   * @param {ResponseType} [responseType] - The response type value\n   * @returns A promise that resolves to the converted response content\n   */\n  static convertResponse(rawResponse, responseType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (rawResponse.status === 204) {\n        // NO CONTENT\n        return Promise.resolve();\n      }\n      let responseValue;\n      const contentType = rawResponse.headers.get(\"Content-type\");\n      switch (responseType) {\n        case ResponseType.ARRAYBUFFER:\n          responseValue = yield rawResponse.arrayBuffer();\n          break;\n        case ResponseType.BLOB:\n          responseValue = yield rawResponse.blob();\n          break;\n        case ResponseType.DOCUMENT:\n          responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, DocumentType.TEXT_XML);\n          break;\n        case ResponseType.JSON:\n          responseValue = yield rawResponse.json();\n          break;\n        case ResponseType.STREAM:\n          responseValue = yield Promise.resolve(rawResponse.body);\n          break;\n        case ResponseType.TEXT:\n          responseValue = yield rawResponse.text();\n          break;\n        default:\n          if (contentType !== null) {\n            const mimeType = contentType.split(\";\")[0];\n            if (new RegExp(ContentTypeRegexStr.DOCUMENT).test(mimeType)) {\n              responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, mimeType);\n            } else if (new RegExp(ContentTypeRegexStr.IMAGE).test(mimeType)) {\n              responseValue = rawResponse.blob();\n            } else if (mimeType === ContentType.TEXT_PLAIN) {\n              responseValue = yield rawResponse.text();\n            } else if (mimeType === ContentType.APPLICATION_JSON) {\n              responseValue = yield rawResponse.json();\n            } else {\n              responseValue = Promise.resolve(rawResponse.body);\n            }\n          } else {\n            /**\n             * RFC specification {@link https://tools.ietf.org/html/rfc7231#section-3.1.1.5} says:\n             *  A sender that generates a message containing a payload body SHOULD\n             *  generate a Content-Type header field in that message unless the\n             *  intended media type of the enclosed representation is unknown to the\n             *  sender.  If a Content-Type header field is not present, the recipient\n             *  MAY either assume a media type of \"application/octet-stream\"\n             *  ([RFC2046], Section 4.5.1) or examine the data to determine its type.\n             *\n             *  So assuming it as a stream type so returning the body.\n             */\n            responseValue = Promise.resolve(rawResponse.body);\n          }\n          break;\n      }\n      return responseValue;\n    });\n  }\n  /**\n   * @public\n   * @static\n   * @async\n   * To get the parsed response\n   * @param {Response} rawResponse - The response object\n   * @param {ResponseType} [responseType] - The response type value\n   * @param {GraphRequestCallback} [callback] - The graph request callback function\n   * @returns The parsed response\n   */\n  static getResponse(rawResponse, responseType, callback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (responseType === ResponseType.RAW) {\n        return Promise.resolve(rawResponse);\n      } else {\n        const response = yield GraphResponseHandler.convertResponse(rawResponse, responseType);\n        if (rawResponse.ok) {\n          // Status Code 2XX\n          if (typeof callback === \"function\") {\n            callback(null, response);\n          } else {\n            return response;\n          }\n        } else {\n          // NOT OK Response\n          throw response;\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["ResponseType","DocumentType","ContentType","ContentTypeRegexStr","GraphResponseHandler","parseDocumentResponse","rawResponse","type","DOMParser","Promise","resolve","reject","text","then","xmlString","parser","xmlDoc","parseFromString","error","body","convertResponse","responseType","status","responseValue","contentType","headers","get","ARRAYBUFFER","arrayBuffer","BLOB","blob","DOCUMENT","TEXT_XML","JSON","json","STREAM","TEXT","mimeType","split","RegExp","test","IMAGE","TEXT_PLAIN","APPLICATION_JSON","getResponse","callback","RAW","response","ok"],"sources":["/Users/nic/housing-deadlines-app/node_modules/@microsoft/microsoft-graph-client/src/GraphResponseHandler.ts"],"sourcesContent":["/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module GraphResponseHandler\n * References - https://fetch.spec.whatwg.org/#responses\n */\n\nimport { GraphRequestCallback } from \"./IGraphRequestCallback\";\nimport { ResponseType } from \"./ResponseType\";\n\n/**\n * @enum\n * Enum for document types\n * @property {string} TEXT_HTML - The text/html content type\n * @property {string} TEXT_XML - The text/xml content type\n * @property {string} APPLICATION_XML - The application/xml content type\n * @property {string} APPLICATION_XHTML - The application/xhml+xml content type\n */\nexport enum DocumentType {\n\tTEXT_HTML = \"text/html\",\n\tTEXT_XML = \"text/xml\",\n\tAPPLICATION_XML = \"application/xml\",\n\tAPPLICATION_XHTML = \"application/xhtml+xml\",\n}\n\n/**\n * @enum\n * Enum for Content types\n * @property {string} TEXT_PLAIN - The text/plain content type\n * @property {string} APPLICATION_JSON - The application/json content type\n */\n\nenum ContentType {\n\tTEXT_PLAIN = \"text/plain\",\n\tAPPLICATION_JSON = \"application/json\",\n}\n\n/**\n * @enum\n * Enum for Content type regex\n * @property {string} DOCUMENT - The regex to match document content types\n * @property {string} IMAGE - The regex to match image content types\n */\nenum ContentTypeRegexStr {\n\tDOCUMENT = \"^(text\\\\/(html|xml))|(application\\\\/(xml|xhtml\\\\+xml))$\",\n\tIMAGE = \"^image\\\\/.+\",\n}\n\n/**\n * @class\n * Class for GraphResponseHandler\n */\n\nexport class GraphResponseHandler {\n\t/**\n\t * @private\n\t * @static\n\t * To parse Document response\n\t * @param {Response} rawResponse - The response object\n\t * @param {DocumentType} type - The type to which the document needs to be parsed\n\t * @returns A promise that resolves to a document content\n\t */\n\tprivate static parseDocumentResponse(rawResponse: Response, type: DocumentType): Promise<any> {\n\t\tif (typeof DOMParser !== \"undefined\") {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\trawResponse.text().then((xmlString) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\tconst xmlDoc = parser.parseFromString(xmlString, type);\n\t\t\t\t\t\tresolve(xmlDoc);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\treturn Promise.resolve(rawResponse.body);\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @static\n\t * @async\n\t * To convert the native Response to response content\n\t * @param {Response} rawResponse - The response object\n\t * @param {ResponseType} [responseType] - The response type value\n\t * @returns A promise that resolves to the converted response content\n\t */\n\tprivate static async convertResponse(rawResponse: Response, responseType?: ResponseType): Promise<any> {\n\t\tif (rawResponse.status === 204) {\n\t\t\t// NO CONTENT\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tlet responseValue: any;\n\t\tconst contentType = rawResponse.headers.get(\"Content-type\");\n\t\tswitch (responseType) {\n\t\t\tcase ResponseType.ARRAYBUFFER:\n\t\t\t\tresponseValue = await rawResponse.arrayBuffer();\n\t\t\t\tbreak;\n\t\t\tcase ResponseType.BLOB:\n\t\t\t\tresponseValue = await rawResponse.blob();\n\t\t\t\tbreak;\n\t\t\tcase ResponseType.DOCUMENT:\n\t\t\t\tresponseValue = await GraphResponseHandler.parseDocumentResponse(rawResponse, DocumentType.TEXT_XML);\n\t\t\t\tbreak;\n\t\t\tcase ResponseType.JSON:\n\t\t\t\tresponseValue = await rawResponse.json();\n\t\t\t\tbreak;\n\t\t\tcase ResponseType.STREAM:\n\t\t\t\tresponseValue = await Promise.resolve(rawResponse.body);\n\t\t\t\tbreak;\n\t\t\tcase ResponseType.TEXT:\n\t\t\t\tresponseValue = await rawResponse.text();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (contentType !== null) {\n\t\t\t\t\tconst mimeType = contentType.split(\";\")[0];\n\t\t\t\t\tif (new RegExp(ContentTypeRegexStr.DOCUMENT).test(mimeType)) {\n\t\t\t\t\t\tresponseValue = await GraphResponseHandler.parseDocumentResponse(rawResponse, mimeType as DocumentType);\n\t\t\t\t\t} else if (new RegExp(ContentTypeRegexStr.IMAGE).test(mimeType)) {\n\t\t\t\t\t\tresponseValue = rawResponse.blob();\n\t\t\t\t\t} else if (mimeType === ContentType.TEXT_PLAIN) {\n\t\t\t\t\t\tresponseValue = await rawResponse.text();\n\t\t\t\t\t} else if (mimeType === ContentType.APPLICATION_JSON) {\n\t\t\t\t\t\tresponseValue = await rawResponse.json();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponseValue = Promise.resolve(rawResponse.body);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/**\n\t\t\t\t\t * RFC specification {@link https://tools.ietf.org/html/rfc7231#section-3.1.1.5} says:\n\t\t\t\t\t *  A sender that generates a message containing a payload body SHOULD\n\t\t\t\t\t *  generate a Content-Type header field in that message unless the\n\t\t\t\t\t *  intended media type of the enclosed representation is unknown to the\n\t\t\t\t\t *  sender.  If a Content-Type header field is not present, the recipient\n\t\t\t\t\t *  MAY either assume a media type of \"application/octet-stream\"\n\t\t\t\t\t *  ([RFC2046], Section 4.5.1) or examine the data to determine its type.\n\t\t\t\t\t *\n\t\t\t\t\t *  So assuming it as a stream type so returning the body.\n\t\t\t\t\t */\n\t\t\t\t\tresponseValue = Promise.resolve(rawResponse.body);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\treturn responseValue;\n\t}\n\n\t/**\n\t * @public\n\t * @static\n\t * @async\n\t * To get the parsed response\n\t * @param {Response} rawResponse - The response object\n\t * @param {ResponseType} [responseType] - The response type value\n\t * @param {GraphRequestCallback} [callback] - The graph request callback function\n\t * @returns The parsed response\n\t */\n\tpublic static async getResponse(rawResponse: Response, responseType?: ResponseType, callback?: GraphRequestCallback): Promise<any> {\n\t\tif (responseType === ResponseType.RAW) {\n\t\t\treturn Promise.resolve(rawResponse);\n\t\t} else {\n\t\t\tconst response = await GraphResponseHandler.convertResponse(rawResponse, responseType);\n\t\t\tif (rawResponse.ok) {\n\t\t\t\t// Status Code 2XX\n\t\t\t\tif (typeof callback === \"function\") {\n\t\t\t\t\tcallback(null, response);\n\t\t\t\t} else {\n\t\t\t\t\treturn response;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// NOT OK Response\n\t\t\t\tthrow response;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}