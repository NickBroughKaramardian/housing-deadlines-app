{"ast":null,"code":"import _objectSpread from\"/Users/nic/housing-deadlines-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{sharedDataService}from'./sharedDataService';import{globalTaskStore}from'./globalTaskStore';import recurringTaskGenerator from'./recurringTaskGenerator';import recurringInstanceService from'./recurringInstanceService';import{format}from'date-fns';/**\n * Centralized task update service for seamless database integration\n * Used by all task card buttons across Dashboard, Sort Deadlines, Calendar, and Gantt Chart\n */class TaskUpdateService{constructor(){// Queue to prevent concurrent updates\nthis.updateQueue=[];this.isProcessing=false;}/**\n   * Update a task field with force-refresh to ensure data integrity\n   * @param {string} taskId - The task ID\n   * @param {object} updates - Fields to update (e.g., { Completed_x003f_: true })\n   * @param {function} onStart - Callback when update starts (for loading indicator)\n   * @param {function} onComplete - Callback when update completes\n   */async updateTaskField(taskId,updates){let onStart=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;let onComplete=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;// Add to queue to prevent concurrent updates\nreturn new Promise((resolve,reject)=>{this.updateQueue.push({taskId,updates,onStart,onComplete,resolve,reject});// Process queue if not already processing\nif(!this.isProcessing){this.processQueue();}});}/**\n   * Process the update queue sequentially to prevent race conditions\n   */async processQueue(){if(this.isProcessing||this.updateQueue.length===0){return;}this.isProcessing=true;while(this.updateQueue.length>0){const update=this.updateQueue.shift();try{await this.processUpdate(update);update.resolve();}catch(error){update.reject(error);}}this.isProcessing=false;}/**\n   * Process a single update\n   */async processUpdate(_ref){let{taskId,updates,onStart,onComplete}=_ref;try{if(onStart)onStart();console.log('TaskUpdateService: Processing queued update for task:',taskId,'with:',updates);// Get task from global store to determine if it's an instance or SharePoint task\nconst allTasks=globalTaskStore.getAllTasks();console.log('TaskUpdateService: Looking for task:',taskId,'in',allTasks.length,'total tasks');const task=allTasks.find(t=>t.id===taskId);if(!task){console.error('TaskUpdateService: Task not found:',taskId);console.error('TaskUpdateService: Available task IDs:',allTasks.map(t=>({id:t.id,isInstance:t.isInstance,originalId:t.originalId})));if(onComplete)onComplete();return;}console.log('TaskUpdateService: Found task:',{id:task.id,isInstance:task.isInstance,originalId:task.originalId});// Determine the field name and value from updates object\nconst field=Object.keys(updates)[0];const processedValue=updates[field];// Check if this is a recurring instance\nif(task.originalId||task.isInstance){// This is a recurring instance - update in IndexedDB\nconsole.log('TaskUpdateService: Updating recurring instance:',taskId);// Get the raw instance from IndexedDB (has baseTask and modifications structure)\nconst allRawInstances=await recurringInstanceService.getAllInstances();console.log('TaskUpdateService: Looking for raw instance with ID:',taskId);console.log('TaskUpdateService: Available raw instance IDs:',allRawInstances.map(i=>i.id));const rawInstance=allRawInstances.find(i=>i.id===taskId);if(!rawInstance){console.error('TaskUpdateService: Raw instance not found:',taskId);console.error('TaskUpdateService: This might be a non-recurring clone that needs different handling');if(onComplete)onComplete();return;}// Determine which field is being updated\nconst field=Object.keys(updates)[0];const value=updates[field];console.log('TaskUpdateService: Updating instance field:',field,'=',value);// CRITICAL: Only update the modifications object, NOT the baseTask\n// The baseTask remains unchanged, modifications are applied on top when displaying\nconst updatedInstance=_objectSpread(_objectSpread({},rawInstance),{},{modifications:_objectSpread(_objectSpread({},rawInstance.modifications),{},{[field]:value}),completionStatus:field==='Completed_x003f_'?value:rawInstance.completionStatus,lastModified:new Date().toISOString()});console.log('TaskUpdateService: Updated instance with modifications:',{instanceId:taskId,field:field,value:value,allModifications:updatedInstance.modifications,completionStatus:updatedInstance.completionStatus,rawInstanceModifications:rawInstance.modifications});await recurringInstanceService.updateInstance(updatedInstance);console.log('TaskUpdateService: Instance updated in IndexedDB successfully');// Refresh instances and convert them to task format\nconst allUpdatedRawInstances=await recurringInstanceService.getAllInstances();const convertedInstances=allUpdatedRawInstances.map(instance=>_objectSpread(_objectSpread({},instance.baseTask),{},{id:instance.id,originalId:instance.parentId,isInstance:true,instanceDate:instance.instanceDate,instanceNumber:instance.instanceNumber,completionStatus:instance.completionStatus,modifications:instance.modifications,createdAt:instance.createdAt,lastModified:instance.lastModified},instance.modifications));console.log('TaskUpdateService: Converted instances for global store:',convertedInstances.length);console.log('TaskUpdateService: Sample converted instance:',convertedInstances.find(i=>i.id===taskId));// Get fresh SharePoint tasks and update global store with combined data\nconst freshTasks=await sharedDataService.getAllTasks();globalTaskStore.setAllTasks([...freshTasks,...convertedInstances]);console.log('TaskUpdateService: Global store updated with',[...freshTasks,...convertedInstances].length,'total items');console.log('TaskUpdateService: Instance update complete');if(onComplete)onComplete();return;}// This is a regular SharePoint task\nconsole.log('TaskUpdateService: Updating SharePoint task with field:',field,'=',processedValue);// Update SharePoint\nawait sharedDataService.updateTask(taskId,{[field]:processedValue});// Clear cache and fetch fresh data\nsharedDataService.clearCache();const freshTasks=await sharedDataService.getAllTasks();globalTaskStore.setTasks(freshTasks);const freshTask=freshTasks.find(t=>t.id===taskId);// Regenerate instances if a recurring field was changed\nif(field==='Recurring'||field==='Interval'||field==='FinalDate'||field==='Deadline'){if(freshTask){console.log('TaskUpdateService: Regenerating instances...');await recurringTaskGenerator.updateTaskInstances(freshTask);}}else if(field==='Completed_x003f_'||field==='Priority'){// For status fields (Completed, Priority), do NOT cascade to instances\n// These should remain independent\nconsole.log('TaskUpdateService: Status field changed, NOT cascading to instances to maintain independence');}else{// For non-recurring, non-status fields, cascade changes to all instances\nif(freshTask&&(freshTask.Recurring===true||freshTask.Recurring==='Yes')){console.log('TaskUpdateService: Cascading parent changes to instances...');await recurringTaskGenerator.cascadeParentChanges(freshTask);}}// Update global store with combined tasks and instances\nconst allInstances=await recurringTaskGenerator.getAllTaskInstances();globalTaskStore.setAllTasks([...freshTasks,...allInstances]);console.log('TaskUpdateService: SharePoint task update complete');if(onComplete)onComplete();}catch(error){console.error('TaskUpdateService: Error updating task:',error);if(onComplete)onComplete();throw error;}}/**\n   * Delete a task with confirmation\n   * @param {string} taskId - The task ID\n   * @param {function} onStart - Callback when deletion starts\n   * @param {function} onComplete - Callback when deletion completes\n   */async deleteTask(taskId){let onStart=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let onComplete=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;try{if(onStart)onStart();console.log('TaskUpdateService: Deleting task:',taskId);// Check if this is a recurring instance\nconst allTasks=globalTaskStore.getAllTasks();const task=allTasks.find(t=>t.id===taskId);if(task&&task.originalId){// This is a recurring instance - delete from IndexedDB\nconsole.log('TaskUpdateService: Deleting recurring instance');await recurringInstanceService.deleteInstance(taskId);}else{// This is a regular SharePoint task - delete from SharePoint\nconsole.log('TaskUpdateService: Deleting SharePoint task');await sharedDataService.deleteTask(taskId);}// Update global store\nglobalTaskStore.deleteTask(taskId);// Force-refresh\nconsole.log('TaskUpdateService: Force-refreshing after deletion...');sharedDataService.clearCache();await new Promise(resolve=>setTimeout(resolve,800));const freshTasks=await sharedDataService.getAllTasks();globalTaskStore.setTasks(freshTasks);const allInstances=await recurringTaskGenerator.getAllTaskInstances();globalTaskStore.setAllTasks([...freshTasks,...allInstances]);console.log('TaskUpdateService: Deletion complete');if(onComplete)onComplete();}catch(error){console.error('TaskUpdateService: Error deleting task:',error);if(onComplete)onComplete();throw error;}}}const taskUpdateService=new TaskUpdateService();export default taskUpdateService;","map":{"version":3,"names":["sharedDataService","globalTaskStore","recurringTaskGenerator","recurringInstanceService","format","TaskUpdateService","constructor","updateQueue","isProcessing","updateTaskField","taskId","updates","onStart","arguments","length","undefined","onComplete","Promise","resolve","reject","push","processQueue","update","shift","processUpdate","error","_ref","console","log","allTasks","getAllTasks","task","find","t","id","map","isInstance","originalId","field","Object","keys","processedValue","allRawInstances","getAllInstances","i","rawInstance","value","updatedInstance","_objectSpread","modifications","completionStatus","lastModified","Date","toISOString","instanceId","allModifications","rawInstanceModifications","updateInstance","allUpdatedRawInstances","convertedInstances","instance","baseTask","parentId","instanceDate","instanceNumber","createdAt","freshTasks","setAllTasks","updateTask","clearCache","setTasks","freshTask","updateTaskInstances","Recurring","cascadeParentChanges","allInstances","getAllTaskInstances","deleteTask","deleteInstance","setTimeout","taskUpdateService"],"sources":["/Users/nic/housing-deadlines-app/VERSION_2.2.0_BACKUP/src/taskUpdateService.js"],"sourcesContent":["import { sharedDataService } from './sharedDataService';\nimport { globalTaskStore } from './globalTaskStore';\nimport recurringTaskGenerator from './recurringTaskGenerator';\nimport recurringInstanceService from './recurringInstanceService';\nimport { format } from 'date-fns';\n\n/**\n * Centralized task update service for seamless database integration\n * Used by all task card buttons across Dashboard, Sort Deadlines, Calendar, and Gantt Chart\n */\nclass TaskUpdateService {\n  constructor() {\n    // Queue to prevent concurrent updates\n    this.updateQueue = [];\n    this.isProcessing = false;\n  }\n  /**\n   * Update a task field with force-refresh to ensure data integrity\n   * @param {string} taskId - The task ID\n   * @param {object} updates - Fields to update (e.g., { Completed_x003f_: true })\n   * @param {function} onStart - Callback when update starts (for loading indicator)\n   * @param {function} onComplete - Callback when update completes\n   */\n  async updateTaskField(taskId, updates, onStart = null, onComplete = null) {\n    // Add to queue to prevent concurrent updates\n    return new Promise((resolve, reject) => {\n      this.updateQueue.push({\n        taskId,\n        updates,\n        onStart,\n        onComplete,\n        resolve,\n        reject\n      });\n      \n      // Process queue if not already processing\n      if (!this.isProcessing) {\n        this.processQueue();\n      }\n    });\n  }\n\n  /**\n   * Process the update queue sequentially to prevent race conditions\n   */\n  async processQueue() {\n    if (this.isProcessing || this.updateQueue.length === 0) {\n      return;\n    }\n    \n    this.isProcessing = true;\n    \n    while (this.updateQueue.length > 0) {\n      const update = this.updateQueue.shift();\n      \n      try {\n        await this.processUpdate(update);\n        update.resolve();\n      } catch (error) {\n        update.reject(error);\n      }\n    }\n    \n    this.isProcessing = false;\n  }\n\n  /**\n   * Process a single update\n   */\n  async processUpdate({ taskId, updates, onStart, onComplete }) {\n    try {\n      if (onStart) onStart();\n      \n      console.log('TaskUpdateService: Processing queued update for task:', taskId, 'with:', updates);\n      \n      // Get task from global store to determine if it's an instance or SharePoint task\n      const allTasks = globalTaskStore.getAllTasks();\n      console.log('TaskUpdateService: Looking for task:', taskId, 'in', allTasks.length, 'total tasks');\n      const task = allTasks.find(t => t.id === taskId);\n      \n      if (!task) {\n        console.error('TaskUpdateService: Task not found:', taskId);\n        console.error('TaskUpdateService: Available task IDs:', allTasks.map(t => ({ id: t.id, isInstance: t.isInstance, originalId: t.originalId })));\n        if (onComplete) onComplete();\n        return;\n      }\n      \n      console.log('TaskUpdateService: Found task:', { id: task.id, isInstance: task.isInstance, originalId: task.originalId });\n      \n      // Determine the field name and value from updates object\n      const field = Object.keys(updates)[0];\n      const processedValue = updates[field];\n      \n      \n      // Check if this is a recurring instance\n      if (task.originalId || task.isInstance) {\n        // This is a recurring instance - update in IndexedDB\n        console.log('TaskUpdateService: Updating recurring instance:', taskId);\n        \n        // Get the raw instance from IndexedDB (has baseTask and modifications structure)\n        const allRawInstances = await recurringInstanceService.getAllInstances();\n        console.log('TaskUpdateService: Looking for raw instance with ID:', taskId);\n        console.log('TaskUpdateService: Available raw instance IDs:', allRawInstances.map(i => i.id));\n        const rawInstance = allRawInstances.find(i => i.id === taskId);\n        \n        if (!rawInstance) {\n          console.error('TaskUpdateService: Raw instance not found:', taskId);\n          console.error('TaskUpdateService: This might be a non-recurring clone that needs different handling');\n          if (onComplete) onComplete();\n          return;\n        }\n        \n        // Determine which field is being updated\n        const field = Object.keys(updates)[0];\n        const value = updates[field];\n        \n        console.log('TaskUpdateService: Updating instance field:', field, '=', value);\n        \n        // CRITICAL: Only update the modifications object, NOT the baseTask\n        // The baseTask remains unchanged, modifications are applied on top when displaying\n        const updatedInstance = {\n          ...rawInstance,\n          modifications: {\n            ...rawInstance.modifications,\n            [field]: value\n          },\n          completionStatus: field === 'Completed_x003f_' ? value : rawInstance.completionStatus,\n          lastModified: new Date().toISOString()\n        };\n        \n        console.log('TaskUpdateService: Updated instance with modifications:', {\n          instanceId: taskId,\n          field: field,\n          value: value,\n          allModifications: updatedInstance.modifications,\n          completionStatus: updatedInstance.completionStatus,\n          rawInstanceModifications: rawInstance.modifications\n        });\n        \n        await recurringInstanceService.updateInstance(updatedInstance);\n        console.log('TaskUpdateService: Instance updated in IndexedDB successfully');\n        \n        // Refresh instances and convert them to task format\n        const allUpdatedRawInstances = await recurringInstanceService.getAllInstances();\n        const convertedInstances = allUpdatedRawInstances.map(instance => ({\n          ...instance.baseTask,\n          id: instance.id,\n          originalId: instance.parentId,\n          isInstance: true,\n          instanceDate: instance.instanceDate,\n          instanceNumber: instance.instanceNumber,\n          completionStatus: instance.completionStatus,\n          modifications: instance.modifications,\n          createdAt: instance.createdAt,\n          lastModified: instance.lastModified,\n          // Apply modifications on top\n          ...instance.modifications\n        }));\n        \n        console.log('TaskUpdateService: Converted instances for global store:', convertedInstances.length);\n        console.log('TaskUpdateService: Sample converted instance:', convertedInstances.find(i => i.id === taskId));\n        \n        // Get fresh SharePoint tasks and update global store with combined data\n        const freshTasks = await sharedDataService.getAllTasks();\n        globalTaskStore.setAllTasks([...freshTasks, ...convertedInstances]);\n        console.log('TaskUpdateService: Global store updated with', [...freshTasks, ...convertedInstances].length, 'total items');\n        \n        console.log('TaskUpdateService: Instance update complete');\n        if (onComplete) onComplete();\n        return;\n      }\n      \n      // This is a regular SharePoint task\n      console.log('TaskUpdateService: Updating SharePoint task with field:', field, '=', processedValue);\n      \n      // Update SharePoint\n      await sharedDataService.updateTask(taskId, { [field]: processedValue });\n      \n      // Clear cache and fetch fresh data\n      sharedDataService.clearCache();\n      const freshTasks = await sharedDataService.getAllTasks();\n      globalTaskStore.setTasks(freshTasks);\n      \n      const freshTask = freshTasks.find(t => t.id === taskId);\n      \n      // Regenerate instances if a recurring field was changed\n      if (field === 'Recurring' || field === 'Interval' || field === 'FinalDate' || field === 'Deadline') {\n        if (freshTask) {\n          console.log('TaskUpdateService: Regenerating instances...');\n          await recurringTaskGenerator.updateTaskInstances(freshTask);\n        }\n      } else if (field === 'Completed_x003f_' || field === 'Priority') {\n        // For status fields (Completed, Priority), do NOT cascade to instances\n        // These should remain independent\n        console.log('TaskUpdateService: Status field changed, NOT cascading to instances to maintain independence');\n      } else {\n        // For non-recurring, non-status fields, cascade changes to all instances\n        if (freshTask && (freshTask.Recurring === true || freshTask.Recurring === 'Yes')) {\n          console.log('TaskUpdateService: Cascading parent changes to instances...');\n          await recurringTaskGenerator.cascadeParentChanges(freshTask);\n        }\n      }\n      \n      // Update global store with combined tasks and instances\n      const allInstances = await recurringTaskGenerator.getAllTaskInstances();\n      globalTaskStore.setAllTasks([...freshTasks, ...allInstances]);\n      \n      console.log('TaskUpdateService: SharePoint task update complete');\n      \n      if (onComplete) onComplete();\n    } catch (error) {\n      console.error('TaskUpdateService: Error updating task:', error);\n      if (onComplete) onComplete();\n      throw error;\n    }\n  }\n  \n  /**\n   * Delete a task with confirmation\n   * @param {string} taskId - The task ID\n   * @param {function} onStart - Callback when deletion starts\n   * @param {function} onComplete - Callback when deletion completes\n   */\n  async deleteTask(taskId, onStart = null, onComplete = null) {\n    try {\n      if (onStart) onStart();\n      \n      console.log('TaskUpdateService: Deleting task:', taskId);\n      \n      // Check if this is a recurring instance\n      const allTasks = globalTaskStore.getAllTasks();\n      const task = allTasks.find(t => t.id === taskId);\n      \n      if (task && task.originalId) {\n        // This is a recurring instance - delete from IndexedDB\n        console.log('TaskUpdateService: Deleting recurring instance');\n        await recurringInstanceService.deleteInstance(taskId);\n      } else {\n        // This is a regular SharePoint task - delete from SharePoint\n        console.log('TaskUpdateService: Deleting SharePoint task');\n        await sharedDataService.deleteTask(taskId);\n      }\n      \n      // Update global store\n      globalTaskStore.deleteTask(taskId);\n      \n      // Force-refresh\n      console.log('TaskUpdateService: Force-refreshing after deletion...');\n      sharedDataService.clearCache();\n      await new Promise(resolve => setTimeout(resolve, 800));\n      \n      const freshTasks = await sharedDataService.getAllTasks();\n      globalTaskStore.setTasks(freshTasks);\n      \n      const allInstances = await recurringTaskGenerator.getAllTaskInstances();\n      globalTaskStore.setAllTasks([...freshTasks, ...allInstances]);\n      \n      console.log('TaskUpdateService: Deletion complete');\n      \n      if (onComplete) onComplete();\n    } catch (error) {\n      console.error('TaskUpdateService: Error deleting task:', error);\n      if (onComplete) onComplete();\n      throw error;\n    }\n  }\n}\n\nconst taskUpdateService = new TaskUpdateService();\nexport default taskUpdateService;\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}