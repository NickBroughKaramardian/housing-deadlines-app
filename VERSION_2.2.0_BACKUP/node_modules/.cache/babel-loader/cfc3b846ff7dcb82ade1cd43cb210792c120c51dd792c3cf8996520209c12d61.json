{"ast":null,"code":"/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\nimport { __awaiter } from \"tslib\";\n/**\n * @module LargeFileUploadTask\n */\nimport { GraphClientError } from \"../GraphClientError\";\nimport { GraphResponseHandler } from \"../GraphResponseHandler\";\nimport { ResponseType } from \"../ResponseType\";\nimport { Range } from \"./FileUploadTask/Range\";\nimport { UploadResult } from \"./FileUploadTask/UploadResult\";\n/**\n * @class\n * Class representing LargeFileUploadTask\n */\nexport class LargeFileUploadTask {\n  /**\n   * @public\n   * @static\n   * @async\n   * Makes request to the server to create an upload session\n   * @param {Client} client - The GraphClient instance\n   * @param {string} requestUrl - The URL to create the upload session\n   * @param {any} payload - The payload that needs to be sent\n   * @param {KeyValuePairObjectStringNumber} headers - The headers that needs to be sent\n   * @returns The promise that resolves to LargeFileUploadSession\n   */\n  static createUploadSession(client, requestUrl, payload) {\n    let headers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      const session = yield client.api(requestUrl).headers(headers).post(payload);\n      const largeFileUploadSession = {\n        url: session.uploadUrl,\n        expiry: new Date(session.expirationDateTime),\n        isCancelled: false\n      };\n      return largeFileUploadSession;\n    });\n  }\n  /**\n   * @public\n   * @constructor\n   * Constructs a LargeFileUploadTask\n   * @param {Client} client - The GraphClient instance\n   * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded\n   * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done\n   * @param {LargeFileUploadTaskOptions} options - The upload task options\n   * @returns An instance of LargeFileUploadTask\n   */\n  constructor(client, file, uploadSession) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    /**\n     * @private\n     * Default value for the rangeSize\n     */\n    this.DEFAULT_FILE_SIZE = 5 * 1024 * 1024;\n    this.client = client;\n    if (!file.sliceFile) {\n      throw new GraphClientError(\"Please pass the FileUpload object, StreamUpload object or any custom implementation of the FileObject interface\");\n    } else {\n      this.file = file;\n    }\n    this.file = file;\n    if (!options.rangeSize) {\n      options.rangeSize = this.DEFAULT_FILE_SIZE;\n    }\n    this.options = options;\n    this.uploadSession = uploadSession;\n    this.nextRange = new Range(0, this.options.rangeSize - 1);\n  }\n  /**\n   * @private\n   * Parses given range string to the Range instance\n   * @param {string[]} ranges - The ranges value\n   * @returns The range instance\n   */\n  parseRange(ranges) {\n    const rangeStr = ranges[0];\n    if (typeof rangeStr === \"undefined\" || rangeStr === \"\") {\n      return new Range();\n    }\n    const firstRange = rangeStr.split(\"-\");\n    const minVal = parseInt(firstRange[0], 10);\n    let maxVal = parseInt(firstRange[1], 10);\n    if (Number.isNaN(maxVal)) {\n      maxVal = this.file.size - 1;\n    }\n    return new Range(minVal, maxVal);\n  }\n  /**\n   * @private\n   * Updates the expiration date and the next range\n   * @param {UploadStatusResponse} response - The response of the upload status\n   * @returns Nothing\n   */\n  updateTaskStatus(response) {\n    this.uploadSession.expiry = new Date(response.expirationDateTime);\n    this.nextRange = this.parseRange(response.nextExpectedRanges);\n  }\n  /**\n   * @public\n   * Gets next range that needs to be uploaded\n   * @returns The range instance\n   */\n  getNextRange() {\n    if (this.nextRange.minValue === -1) {\n      return this.nextRange;\n    }\n    const minVal = this.nextRange.minValue;\n    let maxValue = minVal + this.options.rangeSize - 1;\n    if (maxValue >= this.file.size) {\n      maxValue = this.file.size - 1;\n    }\n    return new Range(minVal, maxValue);\n  }\n  /**\n   * @deprecated This function has been moved into FileObject interface.\n   * @public\n   * Slices the file content to the given range\n   * @param {Range} range - The range value\n   * @returns The sliced ArrayBuffer or Blob\n   */\n  sliceFile(range) {\n    console.warn(\"The LargeFileUploadTask.sliceFile() function has been deprecated and moved into the FileObject interface.\");\n    if (this.file.content instanceof ArrayBuffer || this.file.content instanceof Blob || this.file.content instanceof Uint8Array) {\n      return this.file.content.slice(range.minValue, range.maxValue + 1);\n    }\n    throw new GraphClientError(\"The LargeFileUploadTask.sliceFile() function expects only Blob, ArrayBuffer or Uint8Array file content. Please note that the sliceFile() function is deprecated.\");\n  }\n  /**\n   * @public\n   * @async\n   * Uploads file to the server in a sequential order by slicing the file\n   * @returns The promise resolves to uploaded response\n   */\n  upload() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const uploadEventHandlers = this.options && this.options.uploadEventHandlers;\n      while (!this.uploadSession.isCancelled) {\n        const nextRange = this.getNextRange();\n        if (nextRange.maxValue === -1) {\n          const err = new Error(\"Task with which you are trying to upload is already completed, Please check for your uploaded file\");\n          err.name = \"Invalid Session\";\n          throw err;\n        }\n        const fileSlice = yield this.file.sliceFile(nextRange);\n        const rawResponse = yield this.uploadSliceGetRawResponse(fileSlice, nextRange, this.file.size);\n        if (!rawResponse) {\n          throw new GraphClientError(\"Something went wrong! Large file upload slice response is null.\");\n        }\n        const responseBody = yield GraphResponseHandler.getResponse(rawResponse);\n        /**\n         * (rawResponse.status === 201) -> This condition is applicable for OneDrive, PrintDocument and Outlook APIs.\n         * (rawResponse.status === 200 && responseBody.id) -> This additional condition is applicable only for OneDrive API.\n         */\n        if (rawResponse.status === 201 || rawResponse.status === 200 && responseBody.id) {\n          this.reportProgress(uploadEventHandlers, nextRange);\n          return UploadResult.CreateUploadResult(responseBody, rawResponse.headers);\n        }\n        /* Handling the API issue where the case of Outlook upload response property -'nextExpectedRanges'  is not uniform.\n         * https://github.com/microsoftgraph/msgraph-sdk-serviceissues/issues/39\n         */\n        const res = {\n          expirationDateTime: responseBody.expirationDateTime || responseBody.ExpirationDateTime,\n          nextExpectedRanges: responseBody.NextExpectedRanges || responseBody.nextExpectedRanges\n        };\n        this.updateTaskStatus(res);\n        this.reportProgress(uploadEventHandlers, nextRange);\n      }\n    });\n  }\n  reportProgress(uploadEventHandlers, nextRange) {\n    if (uploadEventHandlers && uploadEventHandlers.progress) {\n      uploadEventHandlers.progress(nextRange, uploadEventHandlers.extraCallbackParam);\n    }\n  }\n  /**\n   * @public\n   * @async\n   * Uploads given slice to the server\n   * @param {ArrayBuffer | Blob | File} fileSlice - The file slice\n   * @param {Range} range - The range value\n   * @param {number} totalSize - The total size of a complete file\n   * @returns The response body of the upload slice result\n   */\n  uploadSlice(fileSlice, range, totalSize) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.client.api(this.uploadSession.url).headers({\n        \"Content-Length\": \"\".concat(range.maxValue - range.minValue + 1),\n        \"Content-Range\": \"bytes \".concat(range.minValue, \"-\").concat(range.maxValue, \"/\").concat(totalSize),\n        \"Content-Type\": \"application/octet-stream\"\n      }).put(fileSlice);\n    });\n  }\n  /**\n   * @public\n   * @async\n   * Uploads given slice to the server\n   * @param {unknown} fileSlice - The file slice\n   * @param {Range} range - The range value\n   * @param {number} totalSize - The total size of a complete file\n   * @returns The raw response of the upload slice result\n   */\n  uploadSliceGetRawResponse(fileSlice, range, totalSize) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.client.api(this.uploadSession.url).headers({\n        \"Content-Length\": \"\".concat(range.maxValue - range.minValue + 1),\n        \"Content-Range\": \"bytes \".concat(range.minValue, \"-\").concat(range.maxValue, \"/\").concat(totalSize),\n        \"Content-Type\": \"application/octet-stream\"\n      }).responseType(ResponseType.RAW).put(fileSlice);\n    });\n  }\n  /**\n   * @public\n   * @async\n   * Deletes upload session in the server\n   * @returns The promise resolves to cancelled response\n   */\n  cancel() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const cancelResponse = yield this.client.api(this.uploadSession.url).responseType(ResponseType.RAW).delete();\n      if (cancelResponse.status === 204) {\n        this.uploadSession.isCancelled = true;\n      }\n      return cancelResponse;\n    });\n  }\n  /**\n   * @public\n   * @async\n   * Gets status for the upload session\n   * @returns The promise resolves to the status enquiry response\n   */\n  getStatus() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this.client.api(this.uploadSession.url).get();\n      this.updateTaskStatus(response);\n      return response;\n    });\n  }\n  /**\n   * @public\n   * @async\n   * Resumes upload session and continue uploading the file from the last sent range\n   * @returns The promise resolves to the uploaded response\n   */\n  resume() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.getStatus();\n      return yield this.upload();\n    });\n  }\n  /**\n   * @public\n   * @async\n   * Get the upload session information\n   * @returns The large file upload session\n   */\n  getUploadSession() {\n    return this.uploadSession;\n  }\n}","map":{"version":3,"names":["GraphClientError","GraphResponseHandler","ResponseType","Range","UploadResult","LargeFileUploadTask","createUploadSession","client","requestUrl","payload","headers","arguments","length","undefined","session","api","post","largeFileUploadSession","url","uploadUrl","expiry","Date","expirationDateTime","isCancelled","constructor","file","uploadSession","options","DEFAULT_FILE_SIZE","sliceFile","rangeSize","nextRange","parseRange","ranges","rangeStr","firstRange","split","minVal","parseInt","maxVal","Number","isNaN","size","updateTaskStatus","response","nextExpectedRanges","getNextRange","minValue","maxValue","range","console","warn","content","ArrayBuffer","Blob","Uint8Array","slice","upload","uploadEventHandlers","err","Error","name","fileSlice","rawResponse","uploadSliceGetRawResponse","responseBody","getResponse","status","id","reportProgress","CreateUploadResult","res","ExpirationDateTime","NextExpectedRanges","progress","extraCallbackParam","uploadSlice","totalSize","concat","put","responseType","RAW","cancel","cancelResponse","delete","getStatus","get","resume","getUploadSession"],"sources":["/Users/nic/housing-deadlines-app/node_modules/@microsoft/microsoft-graph-client/src/tasks/LargeFileUploadTask.ts"],"sourcesContent":["/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module LargeFileUploadTask\n */\n\nimport { GraphClientError } from \"../GraphClientError\";\nimport { GraphResponseHandler } from \"../GraphResponseHandler\";\nimport { Client } from \"../index\";\nimport { ResponseType } from \"../ResponseType\";\nimport { UploadEventHandlers } from \"./FileUploadTask/Interfaces/IUploadEventHandlers\";\nimport { Range } from \"./FileUploadTask/Range\";\nimport { UploadResult } from \"./FileUploadTask/UploadResult\";\n\n/**\n * @interface\n * Signature to representing key value pairs\n * @property {[key: string] : string | number} - The Key value pair\n */\ninterface KeyValuePairObjectStringNumber {\n\t[key: string]: string | number;\n}\n\n/**\n * @interface\n * Signature to represent the resulting response in the status enquiry request\n * @property {string} expirationDateTime - The expiration time of the upload session\n * @property {string[]} nextExpectedRanges - The ranges expected in next consecutive request in the upload\n */\ninterface UploadStatusResponse {\n\texpirationDateTime: string;\n\tnextExpectedRanges: string[];\n}\n\n/**\n * @interface\n * Signature to define options for upload task\n * @property {number} [rangeSize = LargeFileUploadTask.DEFAULT_FILE_SIZE] - Specifies the range chunk size\n * @property {UploadEventHandlers} uploadEventHandlers - UploadEventHandlers attached to an upload task\n */\nexport interface LargeFileUploadTaskOptions {\n\trangeSize?: number;\n\tuploadEventHandlers?: UploadEventHandlers;\n}\n\n/**\n * @interface\n * Signature to represent upload session resulting from the session creation in the server\n * @property {string} url - The URL to which the file upload is made\n * @property {Date} expiry - The expiration of the time of the upload session\n */\nexport interface LargeFileUploadSession {\n\turl: string;\n\texpiry: Date;\n\tisCancelled?: boolean;\n}\n\n/**\n * @type\n * Representing the return type of the sliceFile function that is type of the slice of a given range.\n */\nexport type SliceType = ArrayBuffer | Blob | Uint8Array;\n\n/**\n * @interface\n * Signature to define the properties and content of the file in upload task\n * @property {ArrayBuffer | File} content - The actual file content\n * @property {string} name - Specifies the file name with extension\n * @property {number} size - Specifies size of the file\n */\nexport interface FileObject<T> {\n\tcontent: T;\n\tname: string;\n\tsize: number;\n\tsliceFile(range: Range): SliceType | Promise<SliceType>;\n}\n\n/**\n * @class\n * Class representing LargeFileUploadTask\n */\nexport class LargeFileUploadTask<T> {\n\t/**\n\t * @private\n\t * Default value for the rangeSize\n\t */\n\tprivate DEFAULT_FILE_SIZE: number = 5 * 1024 * 1024;\n\n\t/**\n\t * @protected\n\t * The GraphClient instance\n\t */\n\tprotected client: Client;\n\n\t/**\n\t * @protected\n\t * The object holding file details\n\t */\n\tprotected file: FileObject<T>;\n\n\t/**\n\t * @protected\n\t * The object holding options for the task\n\t */\n\tprotected options: LargeFileUploadTaskOptions;\n\n\t/**\n\t * @protected\n\t * The object for upload session\n\t */\n\tprotected uploadSession: LargeFileUploadSession;\n\n\t/**\n\t * @protected\n\t * The next range needs to be uploaded\n\t */\n\tprotected nextRange: Range;\n\n\t/**\n\t * @public\n\t * @static\n\t * @async\n\t * Makes request to the server to create an upload session\n\t * @param {Client} client - The GraphClient instance\n\t * @param {string} requestUrl - The URL to create the upload session\n\t * @param {any} payload - The payload that needs to be sent\n\t * @param {KeyValuePairObjectStringNumber} headers - The headers that needs to be sent\n\t * @returns The promise that resolves to LargeFileUploadSession\n\t */\n\tpublic static async createUploadSession(client: Client, requestUrl: string, payload: any, headers: KeyValuePairObjectStringNumber = {}): Promise<LargeFileUploadSession> {\n\t\tconst session = await client\n\t\t\t.api(requestUrl)\n\t\t\t.headers(headers)\n\t\t\t.post(payload);\n\t\tconst largeFileUploadSession: LargeFileUploadSession = {\n\t\t\turl: session.uploadUrl,\n\t\t\texpiry: new Date(session.expirationDateTime),\n\t\t\tisCancelled: false,\n\t\t};\n\t\treturn largeFileUploadSession;\n\t}\n\n\t/**\n\t * @public\n\t * @constructor\n\t * Constructs a LargeFileUploadTask\n\t * @param {Client} client - The GraphClient instance\n\t * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded\n\t * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done\n\t * @param {LargeFileUploadTaskOptions} options - The upload task options\n\t * @returns An instance of LargeFileUploadTask\n\t */\n\tpublic constructor(client: Client, file: FileObject<T>, uploadSession: LargeFileUploadSession, options: LargeFileUploadTaskOptions = {}) {\n\t\tthis.client = client;\n\n\t\tif (!file.sliceFile) {\n\t\t\tthrow new GraphClientError(\"Please pass the FileUpload object, StreamUpload object or any custom implementation of the FileObject interface\");\n\t\t} else {\n\t\t\tthis.file = file;\n\t\t}\n\t\tthis.file = file;\n\t\tif (!options.rangeSize) {\n\t\t\toptions.rangeSize = this.DEFAULT_FILE_SIZE;\n\t\t}\n\n\t\tthis.options = options;\n\t\tthis.uploadSession = uploadSession;\n\t\tthis.nextRange = new Range(0, this.options.rangeSize - 1);\n\t}\n\n\t/**\n\t * @private\n\t * Parses given range string to the Range instance\n\t * @param {string[]} ranges - The ranges value\n\t * @returns The range instance\n\t */\n\tprivate parseRange(ranges: string[]): Range {\n\t\tconst rangeStr = ranges[0];\n\t\tif (typeof rangeStr === \"undefined\" || rangeStr === \"\") {\n\t\t\treturn new Range();\n\t\t}\n\t\tconst firstRange = rangeStr.split(\"-\");\n\t\tconst minVal = parseInt(firstRange[0], 10);\n\t\tlet maxVal = parseInt(firstRange[1], 10);\n\t\tif (Number.isNaN(maxVal)) {\n\t\t\tmaxVal = this.file.size - 1;\n\t\t}\n\t\treturn new Range(minVal, maxVal);\n\t}\n\n\t/**\n\t * @private\n\t * Updates the expiration date and the next range\n\t * @param {UploadStatusResponse} response - The response of the upload status\n\t * @returns Nothing\n\t */\n\tprivate updateTaskStatus(response: UploadStatusResponse): void {\n\t\tthis.uploadSession.expiry = new Date(response.expirationDateTime);\n\t\tthis.nextRange = this.parseRange(response.nextExpectedRanges);\n\t}\n\n\t/**\n\t * @public\n\t * Gets next range that needs to be uploaded\n\t * @returns The range instance\n\t */\n\tpublic getNextRange(): Range {\n\t\tif (this.nextRange.minValue === -1) {\n\t\t\treturn this.nextRange;\n\t\t}\n\t\tconst minVal = this.nextRange.minValue;\n\t\tlet maxValue = minVal + this.options.rangeSize - 1;\n\t\tif (maxValue >= this.file.size) {\n\t\t\tmaxValue = this.file.size - 1;\n\t\t}\n\t\treturn new Range(minVal, maxValue);\n\t}\n\n\t/**\n\t * @deprecated This function has been moved into FileObject interface.\n\t * @public\n\t * Slices the file content to the given range\n\t * @param {Range} range - The range value\n\t * @returns The sliced ArrayBuffer or Blob\n\t */\n\tpublic sliceFile(range: Range): ArrayBuffer | Blob {\n\t\tconsole.warn(\"The LargeFileUploadTask.sliceFile() function has been deprecated and moved into the FileObject interface.\");\n\t\tif (this.file.content instanceof ArrayBuffer || this.file.content instanceof Blob || this.file.content instanceof Uint8Array) {\n\t\t\treturn this.file.content.slice(range.minValue, range.maxValue + 1);\n\t\t}\n\t\tthrow new GraphClientError(\"The LargeFileUploadTask.sliceFile() function expects only Blob, ArrayBuffer or Uint8Array file content. Please note that the sliceFile() function is deprecated.\");\n\t}\n\n\t/**\n\t * @public\n\t * @async\n\t * Uploads file to the server in a sequential order by slicing the file\n\t * @returns The promise resolves to uploaded response\n\t */\n\tpublic async upload(): Promise<UploadResult> {\n\t\tconst uploadEventHandlers = this.options && this.options.uploadEventHandlers;\n\t\twhile (!this.uploadSession.isCancelled) {\n\t\t\tconst nextRange = this.getNextRange();\n\t\t\tif (nextRange.maxValue === -1) {\n\t\t\t\tconst err = new Error(\"Task with which you are trying to upload is already completed, Please check for your uploaded file\");\n\t\t\t\terr.name = \"Invalid Session\";\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\tconst fileSlice = await this.file.sliceFile(nextRange);\n\t\t\tconst rawResponse = await this.uploadSliceGetRawResponse(fileSlice, nextRange, this.file.size);\n\t\t\tif (!rawResponse) {\n\t\t\t\tthrow new GraphClientError(\"Something went wrong! Large file upload slice response is null.\");\n\t\t\t}\n\n\t\t\tconst responseBody = await GraphResponseHandler.getResponse(rawResponse);\n\t\t\t/**\n\t\t\t * (rawResponse.status === 201) -> This condition is applicable for OneDrive, PrintDocument and Outlook APIs.\n\t\t\t * (rawResponse.status === 200 && responseBody.id) -> This additional condition is applicable only for OneDrive API.\n\t\t\t */\n\t\t\tif (rawResponse.status === 201 || (rawResponse.status === 200 && responseBody.id)) {\n\t\t\t\tthis.reportProgress(uploadEventHandlers, nextRange);\n\t\t\t\treturn UploadResult.CreateUploadResult(responseBody, rawResponse.headers);\n\t\t\t}\n\n\t\t\t/* Handling the API issue where the case of Outlook upload response property -'nextExpectedRanges'  is not uniform.\n\t\t\t * https://github.com/microsoftgraph/msgraph-sdk-serviceissues/issues/39\n\t\t\t */\n\t\t\tconst res: UploadStatusResponse = {\n\t\t\t\texpirationDateTime: responseBody.expirationDateTime || responseBody.ExpirationDateTime,\n\t\t\t\tnextExpectedRanges: responseBody.NextExpectedRanges || responseBody.nextExpectedRanges,\n\t\t\t};\n\t\t\tthis.updateTaskStatus(res);\n\t\t\tthis.reportProgress(uploadEventHandlers, nextRange);\n\t\t}\n\t}\n\n\tprivate reportProgress(uploadEventHandlers: UploadEventHandlers, nextRange: Range) {\n\t\tif (uploadEventHandlers && uploadEventHandlers.progress) {\n\t\t\tuploadEventHandlers.progress(nextRange, uploadEventHandlers.extraCallbackParam);\n\t\t}\n\t}\n\n\t/**\n\t * @public\n\t * @async\n\t * Uploads given slice to the server\n\t * @param {ArrayBuffer | Blob | File} fileSlice - The file slice\n\t * @param {Range} range - The range value\n\t * @param {number} totalSize - The total size of a complete file\n\t * @returns The response body of the upload slice result\n\t */\n\tpublic async uploadSlice(fileSlice: ArrayBuffer | Blob | File, range: Range, totalSize: number): Promise<unknown> {\n\t\treturn await this.client\n\t\t\t.api(this.uploadSession.url)\n\t\t\t.headers({\n\t\t\t\t\"Content-Length\": `${range.maxValue - range.minValue + 1}`,\n\t\t\t\t\"Content-Range\": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`,\n\t\t\t\t\"Content-Type\": \"application/octet-stream\",\n\t\t\t})\n\t\t\t.put(fileSlice);\n\t}\n\n\t/**\n\t * @public\n\t * @async\n\t * Uploads given slice to the server\n\t * @param {unknown} fileSlice - The file slice\n\t * @param {Range} range - The range value\n\t * @param {number} totalSize - The total size of a complete file\n\t * @returns The raw response of the upload slice result\n\t */\n\tpublic async uploadSliceGetRawResponse(fileSlice: unknown, range: Range, totalSize: number): Promise<Response> {\n\t\treturn await this.client\n\t\t\t.api(this.uploadSession.url)\n\t\t\t.headers({\n\t\t\t\t\"Content-Length\": `${range.maxValue - range.minValue + 1}`,\n\t\t\t\t\"Content-Range\": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`,\n\t\t\t\t\"Content-Type\": \"application/octet-stream\",\n\t\t\t})\n\t\t\t.responseType(ResponseType.RAW)\n\t\t\t.put(fileSlice);\n\t}\n\n\t/**\n\t * @public\n\t * @async\n\t * Deletes upload session in the server\n\t * @returns The promise resolves to cancelled response\n\t */\n\tpublic async cancel(): Promise<unknown> {\n\t\tconst cancelResponse = await this.client\n\t\t\t.api(this.uploadSession.url)\n\t\t\t.responseType(ResponseType.RAW)\n\t\t\t.delete();\n\t\tif (cancelResponse.status === 204) {\n\t\t\tthis.uploadSession.isCancelled = true;\n\t\t}\n\t\treturn cancelResponse;\n\t}\n\n\t/**\n\t * @public\n\t * @async\n\t * Gets status for the upload session\n\t * @returns The promise resolves to the status enquiry response\n\t */\n\tpublic async getStatus(): Promise<unknown> {\n\t\tconst response = await this.client.api(this.uploadSession.url).get();\n\t\tthis.updateTaskStatus(response);\n\t\treturn response;\n\t}\n\n\t/**\n\t * @public\n\t * @async\n\t * Resumes upload session and continue uploading the file from the last sent range\n\t * @returns The promise resolves to the uploaded response\n\t */\n\tpublic async resume(): Promise<unknown> {\n\t\tawait this.getStatus();\n\t\treturn await this.upload();\n\t}\n\n\t/**\n\t * @public\n\t * @async\n\t * Get the upload session information\n\t * @returns The large file upload session\n\t */\n\tpublic getUploadSession(): LargeFileUploadSession {\n\t\treturn this.uploadSession;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}