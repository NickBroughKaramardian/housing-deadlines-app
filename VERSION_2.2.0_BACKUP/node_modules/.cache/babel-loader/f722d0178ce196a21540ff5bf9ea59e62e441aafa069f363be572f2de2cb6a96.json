{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { GraphClientError } from \"../../../GraphClientError\";\n/**\n * @class\n * FileObject class for Readable Stream upload\n */\nexport class StreamUpload {\n  constructor(content, name, size) {\n    this.content = content;\n    this.name = name;\n    this.size = size;\n    if (!content || !name || !size) {\n      throw new GraphClientError(\"Please provide the Readable Stream content, name of the file and size of the file\");\n    }\n  }\n  /**\n   * @public\n   * Slices the file content to the given range\n   * @param {Range} range - The range value\n   * @returns The sliced file part\n   */\n  sliceFile(range) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let rangeSize = range.maxValue - range.minValue + 1;\n      /* readable.readable Is true if it is safe to call readable.read(),\n       * which means the stream has not been destroyed or emitted 'error' or 'end'\n       */\n      const bufs = [];\n      /**\n       * The sliceFile reads the first `rangeSize` number of bytes from the stream.\n       * The previousSlice property is used to seek the range of bytes in the previous slice.\n       * Suppose, the sliceFile reads bytes from `10 - 20` from the stream but the upload of this slice fails.\n       * When the user resumes, the stream will have bytes from position 21.\n       * The previousSlice.Range is used to compare if the requested range is cached in the previousSlice property or present in the Readable Stream.\n       */\n      if (this.previousSlice) {\n        if (range.minValue < this.previousSlice.range.minValue) {\n          throw new GraphClientError(\"An error occurred while uploading the stream. Please restart the stream upload from the first byte of the file.\");\n        }\n        if (range.minValue < this.previousSlice.range.maxValue) {\n          const previousRangeMin = this.previousSlice.range.minValue;\n          const previousRangeMax = this.previousSlice.range.maxValue;\n          // Check if the requested range is same as previously sliced range\n          if (range.minValue === previousRangeMin && range.maxValue === previousRangeMax) {\n            return this.previousSlice.fileSlice;\n          }\n          /**\n           * The following check considers a possibility\n           * of an upload failing after some of the bytes of the previous slice\n           * were successfully uploaded.\n           * Example - Previous slice range - `10 - 20`. Current requested range is `15 - 20`.\n           */\n          if (range.maxValue === previousRangeMax) {\n            return this.previousSlice.fileSlice.slice(range.minValue, range.maxValue + 1);\n          }\n          /**\n           * If an upload fails after some of the bytes of the previous slice\n           * were successfully uploaded and the new Range.Maximum is greater than the previous Range.Maximum\n           * Example - Previous slice range - `10 - 20`. Current requested range is `15 - 25`,\n           * then read the bytes from position 15 to 20 from previousSlice.fileSlice and read bytes from position 21 to 25 from the Readable Stream\n           */\n          bufs.push(this.previousSlice.fileSlice.slice(range.minValue, previousRangeMax + 1));\n          rangeSize = range.maxValue - previousRangeMax;\n        }\n      }\n      if (this.content && this.content.readable) {\n        if (this.content.readableLength >= rangeSize) {\n          bufs.push(this.content.read(rangeSize));\n        } else {\n          bufs.push(yield this.readNBytesFromStream(rangeSize));\n        }\n      } else {\n        throw new GraphClientError(\"Stream is not readable.\");\n      }\n      const slicedChunk = Buffer.concat(bufs);\n      this.previousSlice = {\n        fileSlice: slicedChunk,\n        range\n      };\n      return slicedChunk;\n    });\n  }\n  /**\n   * @private\n   * Reads the specified byte size from the stream\n   * @param {number} size - The size of bytes to be read\n   * @returns Buffer with the given length of data.\n   */\n  readNBytesFromStream(size) {\n    return new Promise((resolve, reject) => {\n      const chunks = [];\n      let remainder = size;\n      let length = 0;\n      this.content.on(\"end\", () => {\n        if (remainder > 0) {\n          return reject(new GraphClientError(\"Stream ended before reading required range size\"));\n        }\n      });\n      this.content.on(\"readable\", () => {\n        /**\n         * (chunk = this.content.read(size)) can return null if size of stream is less than 'size' parameter.\n         * Read the remainder number of bytes from the stream iteratively as they are available.\n         */\n        let chunk;\n        while (length < size && (chunk = this.content.read(remainder)) !== null) {\n          length += chunk.length;\n          chunks.push(chunk);\n          if (remainder > 0) {\n            remainder = size - length;\n          }\n        }\n        if (length === size) {\n          return resolve(Buffer.concat(chunks));\n        }\n        if (!this.content || !this.content.readable) {\n          return reject(new GraphClientError(\"Error encountered while reading the stream during the upload\"));\n        }\n      });\n    });\n  }\n}","map":{"version":3,"names":["GraphClientError","StreamUpload","constructor","content","name","size","sliceFile","range","rangeSize","maxValue","minValue","bufs","previousSlice","previousRangeMin","previousRangeMax","fileSlice","slice","push","readable","readableLength","read","readNBytesFromStream","slicedChunk","Buffer","concat","Promise","resolve","reject","chunks","remainder","length","on","chunk"],"sources":["/Users/nic/housing-deadlines-app/node_modules/@microsoft/microsoft-graph-client/src/tasks/FileUploadTask/FileObjectClasses/StreamUpload.ts"],"sourcesContent":["import { GraphClientError } from \"../../../GraphClientError\";\nimport { FileObject, SliceType } from \"../../LargeFileUploadTask\";\nimport { Range } from \"../Range\";\n\n/**\n * @interface\n * Interface to store slice of a stream and range of the slice.\n * @property {Buffer} fileSlice - The slice of the stream\n * @property {Range} range - The range of the slice\n */\ninterface SliceRecord {\n\tfileSlice: Buffer;\n\trange: Range;\n}\n\n/**\n * @class\n * FileObject class for Readable Stream upload\n */\nexport class StreamUpload implements FileObject<NodeStream> {\n\t/**\n\t * @private\n\t * Represents a cache of the last attempted upload slice.\n\t * This can be used when resuming a previously failed slice upload.\n\t */\n\tprivate previousSlice: SliceRecord;\n\n\tpublic constructor(public content: NodeStream, public name: string, public size: number) {\n\t\tif (!content || !name || !size) {\n\t\t\tthrow new GraphClientError(\"Please provide the Readable Stream content, name of the file and size of the file\");\n\t\t}\n\t}\n\n\t/**\n\t * @public\n\t * Slices the file content to the given range\n\t * @param {Range} range - The range value\n\t * @returns The sliced file part\n\t */\n\tpublic async sliceFile(range: Range): Promise<SliceType> {\n\t\tlet rangeSize = range.maxValue - range.minValue + 1;\n\t\t/* readable.readable Is true if it is safe to call readable.read(),\n\t\t * which means the stream has not been destroyed or emitted 'error' or 'end'\n\t\t */\n\t\tconst bufs = [];\n\n\t\t/**\n\t\t * The sliceFile reads the first `rangeSize` number of bytes from the stream.\n\t\t * The previousSlice property is used to seek the range of bytes in the previous slice.\n\t\t * Suppose, the sliceFile reads bytes from `10 - 20` from the stream but the upload of this slice fails.\n\t\t * When the user resumes, the stream will have bytes from position 21.\n\t\t * The previousSlice.Range is used to compare if the requested range is cached in the previousSlice property or present in the Readable Stream.\n\t\t */\n\t\tif (this.previousSlice) {\n\t\t\tif (range.minValue < this.previousSlice.range.minValue) {\n\t\t\t\tthrow new GraphClientError(\"An error occurred while uploading the stream. Please restart the stream upload from the first byte of the file.\");\n\t\t\t}\n\n\t\t\tif (range.minValue < this.previousSlice.range.maxValue) {\n\t\t\t\tconst previousRangeMin = this.previousSlice.range.minValue;\n\t\t\t\tconst previousRangeMax = this.previousSlice.range.maxValue;\n\n\t\t\t\t// Check if the requested range is same as previously sliced range\n\t\t\t\tif (range.minValue === previousRangeMin && range.maxValue === previousRangeMax) {\n\t\t\t\t\treturn this.previousSlice.fileSlice;\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * The following check considers a possibility\n\t\t\t\t * of an upload failing after some of the bytes of the previous slice\n\t\t\t\t * were successfully uploaded.\n\t\t\t\t * Example - Previous slice range - `10 - 20`. Current requested range is `15 - 20`.\n\t\t\t\t */\n\t\t\t\tif (range.maxValue === previousRangeMax) {\n\t\t\t\t\treturn this.previousSlice.fileSlice.slice(range.minValue, range.maxValue + 1);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * If an upload fails after some of the bytes of the previous slice\n\t\t\t\t * were successfully uploaded and the new Range.Maximum is greater than the previous Range.Maximum\n\t\t\t\t * Example - Previous slice range - `10 - 20`. Current requested range is `15 - 25`,\n\t\t\t\t * then read the bytes from position 15 to 20 from previousSlice.fileSlice and read bytes from position 21 to 25 from the Readable Stream\n\t\t\t\t */\n\t\t\t\tbufs.push(this.previousSlice.fileSlice.slice(range.minValue, previousRangeMax + 1));\n\n\t\t\t\trangeSize = range.maxValue - previousRangeMax;\n\t\t\t}\n\t\t}\n\n\t\tif (this.content && this.content.readable) {\n\t\t\tif (this.content.readableLength >= rangeSize) {\n\t\t\t\tbufs.push(this.content.read(rangeSize));\n\t\t\t} else {\n\t\t\t\tbufs.push(await this.readNBytesFromStream(rangeSize));\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new GraphClientError(\"Stream is not readable.\");\n\t\t}\n\t\tconst slicedChunk = Buffer.concat(bufs);\n\t\tthis.previousSlice = { fileSlice: slicedChunk, range };\n\n\t\treturn slicedChunk;\n\t}\n\n\t/**\n\t * @private\n\t * Reads the specified byte size from the stream\n\t * @param {number} size - The size of bytes to be read\n\t * @returns Buffer with the given length of data.\n\t */\n\n\tprivate readNBytesFromStream(size: number): Promise<Buffer> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst chunks = [];\n\t\t\tlet remainder = size;\n\t\t\tlet length = 0;\n\t\t\tthis.content.on(\"end\", () => {\n\t\t\t\tif (remainder > 0) {\n\t\t\t\t\treturn reject(new GraphClientError(\"Stream ended before reading required range size\"));\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.content.on(\"readable\", () => {\n\t\t\t\t/**\n\t\t\t\t * (chunk = this.content.read(size)) can return null if size of stream is less than 'size' parameter.\n\t\t\t\t * Read the remainder number of bytes from the stream iteratively as they are available.\n\t\t\t\t */\n\t\t\t\tlet chunk;\n\t\t\t\twhile (length < size && (chunk = this.content.read(remainder)) !== null) {\n\t\t\t\t\tlength += chunk.length;\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t\tif (remainder > 0) {\n\t\t\t\t\t\tremainder = size - length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (length === size) {\n\t\t\t\t\treturn resolve(Buffer.concat(chunks));\n\t\t\t\t}\n\n\t\t\t\tif (!this.content || !this.content.readable) {\n\t\t\t\t\treturn reject(new GraphClientError(\"Error encountered while reading the stream during the upload\"));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n"],"mappings":";AAAA,SAASA,gBAAgB,QAAQ,2BAA2B;AAe5D;;;;AAIA,OAAM,MAAOC,YAAY;EAQxBC,YAA0BC,OAAmB,EAASC,IAAY,EAASC,IAAY;IAA7D,KAAAF,OAAO,GAAPA,OAAO;IAAqB,KAAAC,IAAI,GAAJA,IAAI;IAAiB,KAAAC,IAAI,GAAJA,IAAI;IAC9E,IAAI,CAACF,OAAO,IAAI,CAACC,IAAI,IAAI,CAACC,IAAI,EAAE;MAC/B,MAAM,IAAIL,gBAAgB,CAAC,mFAAmF,CAAC;;EAEjH;EAEA;;;;;;EAMaM,SAASA,CAACC,KAAY;;MAClC,IAAIC,SAAS,GAAGD,KAAK,CAACE,QAAQ,GAAGF,KAAK,CAACG,QAAQ,GAAG,CAAC;MACnD;;;MAGA,MAAMC,IAAI,GAAG,EAAE;MAEf;;;;;;;MAOA,IAAI,IAAI,CAACC,aAAa,EAAE;QACvB,IAAIL,KAAK,CAACG,QAAQ,GAAG,IAAI,CAACE,aAAa,CAACL,KAAK,CAACG,QAAQ,EAAE;UACvD,MAAM,IAAIV,gBAAgB,CAAC,iHAAiH,CAAC;;QAG9I,IAAIO,KAAK,CAACG,QAAQ,GAAG,IAAI,CAACE,aAAa,CAACL,KAAK,CAACE,QAAQ,EAAE;UACvD,MAAMI,gBAAgB,GAAG,IAAI,CAACD,aAAa,CAACL,KAAK,CAACG,QAAQ;UAC1D,MAAMI,gBAAgB,GAAG,IAAI,CAACF,aAAa,CAACL,KAAK,CAACE,QAAQ;UAE1D;UACA,IAAIF,KAAK,CAACG,QAAQ,KAAKG,gBAAgB,IAAIN,KAAK,CAACE,QAAQ,KAAKK,gBAAgB,EAAE;YAC/E,OAAO,IAAI,CAACF,aAAa,CAACG,SAAS;;UAGpC;;;;;;UAMA,IAAIR,KAAK,CAACE,QAAQ,KAAKK,gBAAgB,EAAE;YACxC,OAAO,IAAI,CAACF,aAAa,CAACG,SAAS,CAACC,KAAK,CAACT,KAAK,CAACG,QAAQ,EAAEH,KAAK,CAACE,QAAQ,GAAG,CAAC,CAAC;;UAG9E;;;;;;UAMAE,IAAI,CAACM,IAAI,CAAC,IAAI,CAACL,aAAa,CAACG,SAAS,CAACC,KAAK,CAACT,KAAK,CAACG,QAAQ,EAAEI,gBAAgB,GAAG,CAAC,CAAC,CAAC;UAEnFN,SAAS,GAAGD,KAAK,CAACE,QAAQ,GAAGK,gBAAgB;;;MAI/C,IAAI,IAAI,CAACX,OAAO,IAAI,IAAI,CAACA,OAAO,CAACe,QAAQ,EAAE;QAC1C,IAAI,IAAI,CAACf,OAAO,CAACgB,cAAc,IAAIX,SAAS,EAAE;UAC7CG,IAAI,CAACM,IAAI,CAAC,IAAI,CAACd,OAAO,CAACiB,IAAI,CAACZ,SAAS,CAAC,CAAC;SACvC,MAAM;UACNG,IAAI,CAACM,IAAI,CAAC,MAAM,IAAI,CAACI,oBAAoB,CAACb,SAAS,CAAC,CAAC;;OAEtD,MAAM;QACN,MAAM,IAAIR,gBAAgB,CAAC,yBAAyB,CAAC;;MAEtD,MAAMsB,WAAW,GAAGC,MAAM,CAACC,MAAM,CAACb,IAAI,CAAC;MACvC,IAAI,CAACC,aAAa,GAAG;QAAEG,SAAS,EAAEO,WAAW;QAAEf;MAAK,CAAE;MAEtD,OAAOe,WAAW;IACnB,CAAC;;EAED;;;;;;EAOQD,oBAAoBA,CAAChB,IAAY;IACxC,OAAO,IAAIoB,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;MACtC,MAAMC,MAAM,GAAG,EAAE;MACjB,IAAIC,SAAS,GAAGxB,IAAI;MACpB,IAAIyB,MAAM,GAAG,CAAC;MACd,IAAI,CAAC3B,OAAO,CAAC4B,EAAE,CAAC,KAAK,EAAE,MAAK;QAC3B,IAAIF,SAAS,GAAG,CAAC,EAAE;UAClB,OAAOF,MAAM,CAAC,IAAI3B,gBAAgB,CAAC,iDAAiD,CAAC,CAAC;;MAExF,CAAC,CAAC;MACF,IAAI,CAACG,OAAO,CAAC4B,EAAE,CAAC,UAAU,EAAE,MAAK;QAChC;;;;QAIA,IAAIC,KAAK;QACT,OAAOF,MAAM,GAAGzB,IAAI,IAAI,CAAC2B,KAAK,GAAG,IAAI,CAAC7B,OAAO,CAACiB,IAAI,CAACS,SAAS,CAAC,MAAM,IAAI,EAAE;UACxEC,MAAM,IAAIE,KAAK,CAACF,MAAM;UACtBF,MAAM,CAACX,IAAI,CAACe,KAAK,CAAC;UAClB,IAAIH,SAAS,GAAG,CAAC,EAAE;YAClBA,SAAS,GAAGxB,IAAI,GAAGyB,MAAM;;;QAI3B,IAAIA,MAAM,KAAKzB,IAAI,EAAE;UACpB,OAAOqB,OAAO,CAACH,MAAM,CAACC,MAAM,CAACI,MAAM,CAAC,CAAC;;QAGtC,IAAI,CAAC,IAAI,CAACzB,OAAO,IAAI,CAAC,IAAI,CAACA,OAAO,CAACe,QAAQ,EAAE;UAC5C,OAAOS,MAAM,CAAC,IAAI3B,gBAAgB,CAAC,8DAA8D,CAAC,CAAC;;MAErG,CAAC,CAAC;IACH,CAAC,CAAC;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}