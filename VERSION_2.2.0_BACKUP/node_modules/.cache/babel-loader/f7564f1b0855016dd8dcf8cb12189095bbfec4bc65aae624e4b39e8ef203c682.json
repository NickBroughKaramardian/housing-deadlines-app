{"ast":null,"code":"/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\nimport { __awaiter } from \"tslib\";\nimport { MiddlewareControl } from \"./MiddlewareControl\";\nimport { generateUUID } from \"./MiddlewareUtil\";\nimport { httpStatusCode, methodStatusCode } from \"./options/ChaosHandlerData\";\nimport { ChaosHandlerOptions } from \"./options/ChaosHandlerOptions\";\nimport { ChaosStrategy } from \"./options/ChaosStrategy\";\n/**\n * Class representing ChaosHandler\n * @class\n * Class\n * @implements Middleware\n */\nexport class ChaosHandler {\n  /**\n   * @public\n   * @constructor\n   * To create an instance of Testing Handler\n   * @param {ChaosHandlerOptions} [options = new ChaosHandlerOptions()] - The testing handler options instance\n   * @param manualMap - The Map passed by user containing url-statusCode info\n   * @returns An instance of Testing Handler\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new ChaosHandlerOptions();\n    let manualMap = arguments.length > 1 ? arguments[1] : undefined;\n    this.options = options;\n    this.manualMap = manualMap;\n  }\n  /**\n   * Generates responseHeader\n   * @private\n   * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n   * @param {string} requestID - request id\n   * @param {string} requestDate - date of the request\n   * @returns response Header\n   */\n  createResponseHeaders(chaosHandlerOptions, requestID, requestDate) {\n    const responseHeader = chaosHandlerOptions.headers ? new Headers(chaosHandlerOptions.headers) : new Headers();\n    responseHeader.append(\"Cache-Control\", \"no-store\");\n    responseHeader.append(\"request-id\", requestID);\n    responseHeader.append(\"client-request-id\", requestID);\n    responseHeader.append(\"x-ms-ags-diagnostic\", \"\");\n    responseHeader.append(\"Date\", requestDate);\n    responseHeader.append(\"Strict-Transport-Security\", \"\");\n    if (chaosHandlerOptions.statusCode === 429) {\n      // throttling case has to have a timeout scenario\n      responseHeader.append(\"retry-after\", \"3\");\n    }\n    return responseHeader;\n  }\n  /**\n   * Generates responseBody\n   * @private\n   * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n   * @param {string} requestID - request id\n   * @param {string} requestDate - date of the request\n   *  * @returns response body\n   */\n  createResponseBody(chaosHandlerOptions, requestID, requestDate) {\n    if (chaosHandlerOptions.responseBody) {\n      return chaosHandlerOptions.responseBody;\n    }\n    let body;\n    if (chaosHandlerOptions.statusCode >= 400) {\n      const codeMessage = httpStatusCode[chaosHandlerOptions.statusCode];\n      const errMessage = chaosHandlerOptions.statusMessage;\n      body = {\n        error: {\n          code: codeMessage,\n          message: errMessage,\n          innerError: {\n            \"request-id\": requestID,\n            date: requestDate\n          }\n        }\n      };\n    } else {\n      body = {};\n    }\n    return body;\n  }\n  /**\n   * creates a response\n   * @private\n   * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n   * @param {Context} context - Contains the context of the request\n   */\n  createResponse(chaosHandlerOptions, context) {\n    const requestURL = context.request;\n    const requestID = generateUUID();\n    const requestDate = new Date();\n    const responseHeader = this.createResponseHeaders(chaosHandlerOptions, requestID, requestDate.toString());\n    const responseBody = this.createResponseBody(chaosHandlerOptions, requestID, requestDate.toString());\n    const init = {\n      url: requestURL,\n      status: chaosHandlerOptions.statusCode,\n      statusText: chaosHandlerOptions.statusMessage,\n      headers: responseHeader\n    };\n    context.response = new Response(typeof responseBody === \"string\" ? responseBody : JSON.stringify(responseBody), init);\n  }\n  /**\n   * Decides whether to send the request to the graph or not\n   * @private\n   * @param {ChaosHandlerOptions} chaosHandlerOptions - A ChaosHandlerOptions object\n   * @param {Context} context - Contains the context of the request\n   * @returns nothing\n   */\n  sendRequest(chaosHandlerOptions, context) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.setStatusCode(chaosHandlerOptions, context.request, context.options.method);\n      if (chaosHandlerOptions.chaosStrategy === ChaosStrategy.MANUAL && !this.nextMiddleware || Math.floor(Math.random() * 100) < chaosHandlerOptions.chaosPercentage) {\n        this.createResponse(chaosHandlerOptions, context);\n      } else if (this.nextMiddleware) {\n        yield this.nextMiddleware.execute(context);\n      }\n    });\n  }\n  /**\n   * Fetches a random status code for the RANDOM mode from the predefined array\n   * @private\n   * @param {string} requestMethod - the API method for the request\n   * @returns a random status code from a given set of status codes\n   */\n  getRandomStatusCode(requestMethod) {\n    const statusCodeArray = methodStatusCode[requestMethod];\n    return statusCodeArray[Math.floor(Math.random() * statusCodeArray.length)];\n  }\n  /**\n   * To fetch the relative URL out of the complete URL using a predefined regex pattern\n   * @private\n   * @param {string} urlMethod - the complete URL\n   * @returns the string as relative URL\n   */\n  getRelativeURL(urlMethod) {\n    const pattern = /https?:\\/\\/graph\\.microsoft\\.com\\/[^/]+(.+?)(\\?|$)/;\n    let relativeURL;\n    if (pattern.exec(urlMethod) !== null) {\n      relativeURL = pattern.exec(urlMethod)[1];\n    }\n    return relativeURL;\n  }\n  /**\n   * To fetch the status code from the map(if needed), then returns response by calling createResponse\n   * @private\n   * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n   * @param {string} requestURL - the URL for the request\n   * @param {string} requestMethod - the API method for the request\n   */\n  setStatusCode(chaosHandlerOptions, requestURL, requestMethod) {\n    if (chaosHandlerOptions.chaosStrategy === ChaosStrategy.MANUAL) {\n      if (chaosHandlerOptions.statusCode === undefined) {\n        // manual mode with no status code, can be a global level or request level without statusCode\n        const relativeURL = this.getRelativeURL(requestURL);\n        if (this.manualMap.get(relativeURL) !== undefined) {\n          // checking Manual Map for exact match\n          if (this.manualMap.get(relativeURL).get(requestMethod) !== undefined) {\n            chaosHandlerOptions.statusCode = this.manualMap.get(relativeURL).get(requestMethod);\n          }\n          // else statusCode would be undefined\n        } else {\n          // checking for regex match if exact match doesn't work\n          this.manualMap.forEach((value, key) => {\n            const regexURL = new RegExp(key + \"$\");\n            if (regexURL.test(relativeURL)) {\n              if (this.manualMap.get(key).get(requestMethod) !== undefined) {\n                chaosHandlerOptions.statusCode = this.manualMap.get(key).get(requestMethod);\n              }\n              // else statusCode would be undefined\n            }\n          });\n        }\n        // Case of redirection or request url not in map ---> statusCode would be undefined\n      }\n    } else {\n      // Handling the case of Random here\n      chaosHandlerOptions.statusCode = this.getRandomStatusCode(requestMethod);\n      // else statusCode would be undefined\n    }\n  }\n  /**\n   * To get the options for execution of the middleware\n   * @private\n   * @param {Context} context - The context object\n   * @returns options for middleware execution\n   */\n  getOptions(context) {\n    let options;\n    if (context.middlewareControl instanceof MiddlewareControl) {\n      options = context.middlewareControl.getMiddlewareOptions(ChaosHandlerOptions);\n    }\n    if (typeof options === \"undefined\") {\n      options = Object.assign(new ChaosHandlerOptions(), this.options);\n    }\n    return options;\n  }\n  /**\n   * To execute the current middleware\n   * @public\n   * @async\n   * @param {Context} context - The context object of the request\n   * @returns A Promise that resolves to nothing\n   */\n  execute(context) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const chaosHandlerOptions = this.getOptions(context);\n      return yield this.sendRequest(chaosHandlerOptions, context);\n    });\n  }\n  /**\n   * @public\n   * To set the next middleware in the chain\n   * @param {Middleware} next - The middleware instance\n   * @returns Nothing\n   */\n  setNext(next) {\n    this.nextMiddleware = next;\n  }\n}","map":{"version":3,"names":["MiddlewareControl","generateUUID","httpStatusCode","methodStatusCode","ChaosHandlerOptions","ChaosStrategy","ChaosHandler","constructor","options","arguments","length","undefined","manualMap","createResponseHeaders","chaosHandlerOptions","requestID","requestDate","responseHeader","headers","Headers","append","statusCode","createResponseBody","responseBody","body","codeMessage","errMessage","statusMessage","error","code","message","innerError","date","createResponse","context","requestURL","request","Date","toString","init","url","status","statusText","response","Response","JSON","stringify","sendRequest","setStatusCode","method","chaosStrategy","MANUAL","nextMiddleware","Math","floor","random","chaosPercentage","execute","getRandomStatusCode","requestMethod","statusCodeArray","getRelativeURL","urlMethod","pattern","relativeURL","exec","get","forEach","value","key","regexURL","RegExp","test","getOptions","middlewareControl","getMiddlewareOptions","Object","assign","setNext","next"],"sources":["/Users/nic/housing-deadlines-app/node_modules/@microsoft/microsoft-graph-client/src/middleware/ChaosHandler.ts"],"sourcesContent":["/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module ChaosHandler\n */\n\nimport { Context } from \"../IContext\";\nimport { RequestMethod } from \"../RequestMethod\";\nimport { Middleware } from \"./IMiddleware\";\nimport { MiddlewareControl } from \"./MiddlewareControl\";\nimport { generateUUID } from \"./MiddlewareUtil\";\nimport { httpStatusCode, methodStatusCode } from \"./options/ChaosHandlerData\";\nimport { ChaosHandlerOptions } from \"./options/ChaosHandlerOptions\";\nimport { ChaosStrategy } from \"./options/ChaosStrategy\";\n\n/**\n * Class representing ChaosHandler\n * @class\n * Class\n * @implements Middleware\n */\nexport class ChaosHandler implements Middleware {\n\t/**\n\t * A member holding options to customize the handler behavior\n\t *\n\t * @private\n\t */\n\tprivate options: ChaosHandlerOptions;\n\n\t/**\n\t * container for the manual map that has been written by the client\n\t *\n\t * @private\n\t */\n\tprivate manualMap: Map<string, Map<string, number>>;\n\n\t/**\n\t * @private\n\t * A member to hold next middleware in the middleware chain\n\t */\n\tprivate nextMiddleware: Middleware;\n\n\t/**\n\t * @public\n\t * @constructor\n\t * To create an instance of Testing Handler\n\t * @param {ChaosHandlerOptions} [options = new ChaosHandlerOptions()] - The testing handler options instance\n\t * @param manualMap - The Map passed by user containing url-statusCode info\n\t * @returns An instance of Testing Handler\n\t */\n\tpublic constructor(options: ChaosHandlerOptions = new ChaosHandlerOptions(), manualMap?: Map<string, Map<string, number>>) {\n\t\tthis.options = options;\n\t\tthis.manualMap = manualMap;\n\t}\n\n\t/**\n\t * Generates responseHeader\n\t * @private\n\t * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n\t * @param {string} requestID - request id\n\t * @param {string} requestDate - date of the request\n\t * @returns response Header\n\t */\n\tprivate createResponseHeaders(chaosHandlerOptions: ChaosHandlerOptions, requestID: string, requestDate: string) {\n\t\tconst responseHeader: Headers = chaosHandlerOptions.headers ? new Headers(chaosHandlerOptions.headers) : new Headers();\n\t\tresponseHeader.append(\"Cache-Control\", \"no-store\");\n\t\tresponseHeader.append(\"request-id\", requestID);\n\t\tresponseHeader.append(\"client-request-id\", requestID);\n\t\tresponseHeader.append(\"x-ms-ags-diagnostic\", \"\");\n\t\tresponseHeader.append(\"Date\", requestDate);\n\t\tresponseHeader.append(\"Strict-Transport-Security\", \"\");\n\n\t\tif (chaosHandlerOptions.statusCode === 429) {\n\t\t\t// throttling case has to have a timeout scenario\n\t\t\tresponseHeader.append(\"retry-after\", \"3\");\n\t\t}\n\n\t\treturn responseHeader;\n\t}\n\n\t/**\n\t * Generates responseBody\n\t * @private\n\t * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n\t * @param {string} requestID - request id\n\t * @param {string} requestDate - date of the request\n\t *  * @returns response body\n\t */\n\tprivate createResponseBody(chaosHandlerOptions: ChaosHandlerOptions, requestID: string, requestDate: string) {\n\t\tif (chaosHandlerOptions.responseBody) {\n\t\t\treturn chaosHandlerOptions.responseBody;\n\t\t}\n\t\tlet body: any;\n\t\tif (chaosHandlerOptions.statusCode >= 400) {\n\t\t\tconst codeMessage: string = httpStatusCode[chaosHandlerOptions.statusCode];\n\t\t\tconst errMessage: string = chaosHandlerOptions.statusMessage;\n\n\t\t\tbody = {\n\t\t\t\terror: {\n\t\t\t\t\tcode: codeMessage,\n\t\t\t\t\tmessage: errMessage,\n\t\t\t\t\tinnerError: {\n\t\t\t\t\t\t\"request-id\": requestID,\n\t\t\t\t\t\tdate: requestDate,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tbody = {};\n\t\t}\n\t\treturn body;\n\t}\n\n\t/**\n\t * creates a response\n\t * @private\n\t * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n\t * @param {Context} context - Contains the context of the request\n\t */\n\tprivate createResponse(chaosHandlerOptions: ChaosHandlerOptions, context: Context) {\n\t\tconst requestURL = context.request as string;\n\t\tconst requestID = generateUUID();\n\t\tconst requestDate = new Date();\n\t\tconst responseHeader = this.createResponseHeaders(chaosHandlerOptions, requestID, requestDate.toString());\n\t\tconst responseBody = this.createResponseBody(chaosHandlerOptions, requestID, requestDate.toString());\n\t\tconst init: any = { url: requestURL, status: chaosHandlerOptions.statusCode, statusText: chaosHandlerOptions.statusMessage, headers: responseHeader };\n\t\tcontext.response = new Response(typeof responseBody === \"string\" ? responseBody : JSON.stringify(responseBody), init);\n\t}\n\n\t/**\n\t * Decides whether to send the request to the graph or not\n\t * @private\n\t * @param {ChaosHandlerOptions} chaosHandlerOptions - A ChaosHandlerOptions object\n\t * @param {Context} context - Contains the context of the request\n\t * @returns nothing\n\t */\n\tprivate async sendRequest(chaosHandlerOptions: ChaosHandlerOptions, context: Context): Promise<void> {\n\t\tthis.setStatusCode(chaosHandlerOptions, context.request as string, context.options.method as RequestMethod);\n\t\tif ((chaosHandlerOptions.chaosStrategy === ChaosStrategy.MANUAL && !this.nextMiddleware) || Math.floor(Math.random() * 100) < chaosHandlerOptions.chaosPercentage) {\n\t\t\tthis.createResponse(chaosHandlerOptions, context);\n\t\t} else if (this.nextMiddleware) {\n\t\t\tawait this.nextMiddleware.execute(context);\n\t\t}\n\t}\n\n\t/**\n\t * Fetches a random status code for the RANDOM mode from the predefined array\n\t * @private\n\t * @param {string} requestMethod - the API method for the request\n\t * @returns a random status code from a given set of status codes\n\t */\n\tprivate getRandomStatusCode(requestMethod: RequestMethod): number {\n\t\tconst statusCodeArray: number[] = methodStatusCode[requestMethod] as number[];\n\t\treturn statusCodeArray[Math.floor(Math.random() * statusCodeArray.length)];\n\t}\n\n\t/**\n\t * To fetch the relative URL out of the complete URL using a predefined regex pattern\n\t * @private\n\t * @param {string} urlMethod - the complete URL\n\t * @returns the string as relative URL\n\t */\n\tprivate getRelativeURL(urlMethod: string): string {\n\t\tconst pattern = /https?:\\/\\/graph\\.microsoft\\.com\\/[^/]+(.+?)(\\?|$)/;\n\t\tlet relativeURL: string;\n\t\tif (pattern.exec(urlMethod) !== null) {\n\t\t\trelativeURL = pattern.exec(urlMethod)[1];\n\t\t}\n\t\treturn relativeURL;\n\t}\n\n\t/**\n\t * To fetch the status code from the map(if needed), then returns response by calling createResponse\n\t * @private\n\t * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n\t * @param {string} requestURL - the URL for the request\n\t * @param {string} requestMethod - the API method for the request\n\t */\n\tprivate setStatusCode(chaosHandlerOptions: ChaosHandlerOptions, requestURL: string, requestMethod: RequestMethod) {\n\t\tif (chaosHandlerOptions.chaosStrategy === ChaosStrategy.MANUAL) {\n\t\t\tif (chaosHandlerOptions.statusCode === undefined) {\n\t\t\t\t// manual mode with no status code, can be a global level or request level without statusCode\n\t\t\t\tconst relativeURL: string = this.getRelativeURL(requestURL);\n\t\t\t\tif (this.manualMap.get(relativeURL) !== undefined) {\n\t\t\t\t\t// checking Manual Map for exact match\n\t\t\t\t\tif (this.manualMap.get(relativeURL).get(requestMethod) !== undefined) {\n\t\t\t\t\t\tchaosHandlerOptions.statusCode = this.manualMap.get(relativeURL).get(requestMethod);\n\t\t\t\t\t}\n\t\t\t\t\t// else statusCode would be undefined\n\t\t\t\t} else {\n\t\t\t\t\t// checking for regex match if exact match doesn't work\n\t\t\t\t\tthis.manualMap.forEach((value: Map<string, number>, key: string) => {\n\t\t\t\t\t\tconst regexURL = new RegExp(key + \"$\");\n\t\t\t\t\t\tif (regexURL.test(relativeURL)) {\n\t\t\t\t\t\t\tif (this.manualMap.get(key).get(requestMethod) !== undefined) {\n\t\t\t\t\t\t\t\tchaosHandlerOptions.statusCode = this.manualMap.get(key).get(requestMethod);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// else statusCode would be undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Case of redirection or request url not in map ---> statusCode would be undefined\n\t\t\t}\n\t\t} else {\n\t\t\t// Handling the case of Random here\n\t\t\tchaosHandlerOptions.statusCode = this.getRandomStatusCode(requestMethod);\n\t\t\t// else statusCode would be undefined\n\t\t}\n\t}\n\n\t/**\n\t * To get the options for execution of the middleware\n\t * @private\n\t * @param {Context} context - The context object\n\t * @returns options for middleware execution\n\t */\n\tprivate getOptions(context: Context): ChaosHandlerOptions {\n\t\tlet options: ChaosHandlerOptions;\n\t\tif (context.middlewareControl instanceof MiddlewareControl) {\n\t\t\toptions = context.middlewareControl.getMiddlewareOptions(ChaosHandlerOptions) as ChaosHandlerOptions;\n\t\t}\n\t\tif (typeof options === \"undefined\") {\n\t\t\toptions = Object.assign(new ChaosHandlerOptions(), this.options);\n\t\t}\n\n\t\treturn options;\n\t}\n\n\t/**\n\t * To execute the current middleware\n\t * @public\n\t * @async\n\t * @param {Context} context - The context object of the request\n\t * @returns A Promise that resolves to nothing\n\t */\n\tpublic async execute(context: Context): Promise<void> {\n\t\tconst chaosHandlerOptions: ChaosHandlerOptions = this.getOptions(context);\n\t\treturn await this.sendRequest(chaosHandlerOptions, context);\n\t}\n\n\t/**\n\t * @public\n\t * To set the next middleware in the chain\n\t * @param {Middleware} next - The middleware instance\n\t * @returns Nothing\n\t */\n\tpublic setNext(next: Middleware): void {\n\t\tthis.nextMiddleware = next;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}